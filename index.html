<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="IDES Data Preparation - Java : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>IDES Data Preparation - Java</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/IRSgov/IDES-Data-Preparation-Java">View on GitHub</a>

          <h1 id="project_title">IDES Data Preparation - Java</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/IRSgov/IDES-Data-Preparation-Java/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/IRSgov/IDES-Data-Preparation-Java/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>
<a id="ides-data-preparation" class="anchor" href="#ides-data-preparation" aria-hidden="true"><span class="octicon octicon-link"></span></a>IDES Data Preparation</h2>

<p>The International Data Exchange Service (IDES) is a secure managed file transfer service that allows financial institutions and tax authorities to securely send information on financial accounts held by U.S. taxpayers in accordance with the Foreign Account Tax Compliance Act (FATCA). Files transmitted via IDES must be encrypted and packaged in accordance with published data preparation instructions.  The data preparation process is an important step to ensure that information transmitted via IDES conforms to U.S security standards to safeguard sensitive information.</p>

<p>The IDES Data Preparation Java project repository demonstrates a sample working application built using Java inside of <a href="http://www.eclipse.org/">Eclipse</a>.  An application was also developed using .Net, see <a href="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net">IDES Data Preparation .Net</a> for more information.</p>

<p>The example explains how to use the code to develop an application that will create an IDES data packet and decrypt notifications. The project starts with a validated FATCA XML file. The application does not validate the XML or metadata schemas. The sample application will digitally sign, encrypt, compress, and archive the data packet into a compliant .ZIP format.  </p>

<p>Please note that there are many open market tools that produce the same results; however, the IRS does not endorse any commercial products, including the frameworks used in the example.  </p>

<h3>
<a id="application-setup" class="anchor" href="#application-setup" aria-hidden="true"><span class="octicon octicon-link"></span></a>Application Setup</h3>

<p>The sample application was created using Eclipse 4.4.1 and JRE version 1.8.0_40. </p>

<p>This repository includes a .zip file that contains several files necessary to this sample application. While some files can be copied and pasted from this guide, some must be downloaded from the .zip file and placed as indicated by the guide.</p>

<p>Keystore - This folder contains a set of .jks files containing self-signed test public and private keys used by the application.</p>

<p>lib - This folder contains the log4j-1.2.16.jar file which provides the console logging for the application.</p>

<p>generated - This folder has a set of .java files related to the metadata used by the application.</p>

<p>src - This folder has the main set of .java files, including testmain.java which is used to start the application.</p>

<p>000000.00000.TA.124_0_Payload.xml - This is the FATCA XML that will be signed, encrypted, and packaged by the application. This is a test file for the application and is not intended to portray a specific business case.</p>

<h3>
<a id="create-a-new-project" class="anchor" href="#create-a-new-project" aria-hidden="true"><span class="octicon octicon-link"></span></a>Create a New Project</h3>

<p>Open <strong>Eclipse</strong>, select <strong>New</strong>, select <strong>Java Project</strong>. </p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image1.png" alt="Image 1"><br>
Figure 1   </p>

<p>Enter <strong>IDESDataPreparation</strong> for the Project Name and select the JRE that you will use. The sample is using jre1.8.0_40. Click the <strong>Next</strong> button.</p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image2.png" alt="Image 2"><br>
Figure 2     </p>

<p>Click <strong>Finish</strong>, these will be set up later</p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image3.png" alt="Image 3"><br>
Figure 3</p>

<p>The Eclipse project with the default settings:
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image4.png" alt="Image 4"><br>
Figure 4</p>

<p>The file system for the new project:
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image5.png" alt="Image 5"><br>
Figure 5</p>

<h2>
<a id="generated-folder" class="anchor" href="#generated-folder" aria-hidden="true"><span class="octicon octicon-link"></span></a>generated folder</h2>

<p>Add the generated folder from the .zip repository or replicate the folder structure below. 
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image6.png" alt="Image 6"><br>
Figure 6</p>

<ol>
<li>Add code for FATCAEntCommunicationTypeCdType.java</li>
</ol>

<pre><code>//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 
// See &lt;a href="http://java.sun.com/xml/jaxb"&gt;http://java.sun.com/xml/jaxb&lt;/a&gt; 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2014.11.05 at 11:20:51 AM EST 
//


package fatca.idessenderfilemetadata;

import javax.xml.bind.annotation.XmlEnum;
import javax.xml.bind.annotation.XmlType;


/**
 * &lt;p&gt;Java class for FATCAEntCommunicationTypeCdType.
 * 
 * &lt;p&gt;The following schema fragment specifies the expected content contained within this class.
 * &lt;p&gt;
 * &lt;pre&gt;
 * &amp;lt;simpleType name="FATCAEntCommunicationTypeCdType"&gt;
 *   &amp;lt;restriction base="{http://www.w3.org/2001/XMLSchema}string"&gt;
 *     &amp;lt;enumeration value="NTF"/&gt;
 *     &amp;lt;enumeration value="RPT"/&gt;
 *   &amp;lt;/restriction&gt;
 * &amp;lt;/simpleType&gt;
 * &lt;/pre&gt;
 * 
 */
@XmlType(name = "FATCAEntCommunicationTypeCdType")
@XmlEnum
public enum FATCAEntCommunicationTypeCdType {


    /**
     * FATCA_NOTIFICATION - FATCA Notification communication
     * 
     */
    NTF,

    /**
     * FATCA_REPORT - FATCA Report communication
     * 
     */
    RPT;

    public String value() {
        return name();
    }

    public static FATCAEntCommunicationTypeCdType fromValue(String v) {
        return valueOf(v);
    }

}

</code></pre>

<ol>
<li>Add code for FATCAIDESSenderFileMetadataType.java</li>
</ol>

<pre><code>//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 
// See &lt;a href="http://java.sun.com/xml/jaxb"&gt;http://java.sun.com/xml/jaxb&lt;/a&gt; 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2014.11.05 at 11:20:51 AM EST 
//


package fatca.idessenderfilemetadata;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.datatype.XMLGregorianCalendar;


/**
 * 
 *              
 * &lt;pre&gt;
 * &amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;&amp;lt;Component xmlns="urn:fatca:idessenderfilemetadata" xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&amp;gt;&amp;lt;DictionaryEntryNm&amp;gt;FATCA IDES Sender File Metadata Type&amp;lt;/DictionaryEntryNm&amp;gt;&amp;lt;MajorVersionNum&amp;gt;1&amp;lt;/MajorVersionNum&amp;gt;&amp;lt;MinorVersionNum&amp;gt;0&amp;lt;/MinorVersionNum&amp;gt;&amp;lt;VersionEffectiveBeginDt&amp;gt;2014-08-29&amp;lt;/VersionEffectiveBeginDt&amp;gt;&amp;lt;VersionDescriptionTxt&amp;gt;Initial Version&amp;lt;/VersionDescriptionTxt&amp;gt;&amp;lt;Description&amp;gt;Type for a group that defines the information contained in the FATCA IDES Sender File Metadata&amp;lt;/Description&amp;gt;
 *              &amp;lt;/Component&amp;gt;
 * &lt;/pre&gt;
 * 
 *          
 * 
 * &lt;p&gt;Java class for FATCAIDESSenderFileMetadataType complex type.
 * 
 * &lt;p&gt;The following schema fragment specifies the expected content contained within this class.
 * 
 * &lt;pre&gt;
 * &amp;lt;complexType name="FATCAIDESSenderFileMetadataType"&gt;
 *   &amp;lt;complexContent&gt;
 *     &amp;lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &amp;lt;sequence&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}FATCAEntitySenderId"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}FATCAEntityReceiverId"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}FATCAEntCommunicationTypeCd"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}SenderFileId"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}FileCreateTs"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}TaxYear"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}FileRevisionInd"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}OriginalIDESTransmissionId" minOccurs="0"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}SenderContactEmailAddressTxt" minOccurs="0"/&gt;
 *       &amp;lt;/sequence&gt;
 *     &amp;lt;/restriction&gt;
 *   &amp;lt;/complexContent&gt;
 * &amp;lt;/complexType&gt;
 * &lt;/pre&gt;
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "FATCAIDESSenderFileMetadataType", propOrder = {
    "fatcaEntitySenderId",
    "fatcaEntityReceiverId",
    "fatcaEntCommunicationTypeCd",
    "senderFileId",
    "fileCreateTs",
    "taxYear",
    "fileRevisionInd",
    "originalIDESTransmissionId",
    "senderContactEmailAddressTxt"
})
public class FATCAIDESSenderFileMetadataType {

    @XmlElement(name = "FATCAEntitySenderId", required = true)
    protected String fatcaEntitySenderId;
    @XmlElement(name = "FATCAEntityReceiverId", required = true)
    protected String fatcaEntityReceiverId;
    @XmlElement(name = "FATCAEntCommunicationTypeCd", required = true)
    protected FATCAEntCommunicationTypeCdType fatcaEntCommunicationTypeCd;
    @XmlElement(name = "SenderFileId", required = true)
    protected String senderFileId;
    @XmlElement(name = "FileCreateTs", required = true)
    protected String fileCreateTs;
    @XmlElement(name = "TaxYear", required = true)
    protected XMLGregorianCalendar taxYear;
    @XmlElement(name = "FileRevisionInd")
    protected boolean fileRevisionInd;
    @XmlElement(name = "OriginalIDESTransmissionId")
    protected String originalIDESTransmissionId;
    @XmlElement(name = "SenderContactEmailAddressTxt")
    protected String senderContactEmailAddressTxt;

    /**
     * Gets the value of the fatcaEntitySenderId property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getFATCAEntitySenderId() {
        return fatcaEntitySenderId;
    }

    /**
     * Sets the value of the fatcaEntitySenderId property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setFATCAEntitySenderId(String value) {
        this.fatcaEntitySenderId = value;
    }

    /**
     * Gets the value of the fatcaEntityReceiverId property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getFATCAEntityReceiverId() {
        return fatcaEntityReceiverId;
    }

    /**
     * Sets the value of the fatcaEntityReceiverId property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setFATCAEntityReceiverId(String value) {
        this.fatcaEntityReceiverId = value;
    }

    /**
     * Gets the value of the fatcaEntCommunicationTypeCd property.
     * 
     * @return
     *     possible object is
     *     {@link FATCAEntCommunicationTypeCdType }
     *     
     */
    public FATCAEntCommunicationTypeCdType getFATCAEntCommunicationTypeCd() {
        return fatcaEntCommunicationTypeCd;
    }

    /**
     * Sets the value of the fatcaEntCommunicationTypeCd property.
     * 
     * @param value
     *     allowed object is
     *     {@link FATCAEntCommunicationTypeCdType }
     *     
     */
    public void setFATCAEntCommunicationTypeCd(FATCAEntCommunicationTypeCdType value) {
        this.fatcaEntCommunicationTypeCd = value;
    }

    /**
     * Gets the value of the senderFileId property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getSenderFileId() {
        return senderFileId;
    }

    /**
     * Sets the value of the senderFileId property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setSenderFileId(String value) {
        this.senderFileId = value;
    }

    /**
     * Gets the value of the fileCreateTs property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getFileCreateTs() {
        return fileCreateTs;
    }

    /**
     * Sets the value of the fileCreateTs property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setFileCreateTs(String value) {
        this.fileCreateTs = value;
    }

    /**
     * Gets the value of the taxYear property.
     * 
     * @return
     *     possible object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public XMLGregorianCalendar getTaxYear() {
        return taxYear;
    }

    /**
     * Sets the value of the taxYear property.
     * 
     * @param value
     *     allowed object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public void setTaxYear(XMLGregorianCalendar value) {
        this.taxYear = value;
    }

    /**
     * Gets the value of the fileRevisionInd property.
     * 
     */
    public boolean isFileRevisionInd() {
        return fileRevisionInd;
    }

    /**
     * Sets the value of the fileRevisionInd property.
     * 
     */
    public void setFileRevisionInd(boolean value) {
        this.fileRevisionInd = value;
    }

    /**
     * Gets the value of the originalIDESTransmissionId property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getOriginalIDESTransmissionId() {
        return originalIDESTransmissionId;
    }

    /**
     * Sets the value of the originalIDESTransmissionId property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setOriginalIDESTransmissionId(String value) {
        this.originalIDESTransmissionId = value;
    }

    /**
     * Gets the value of the senderContactEmailAddressTxt property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getSenderContactEmailAddressTxt() {
        return senderContactEmailAddressTxt;
    }

    /**
     * Sets the value of the senderContactEmailAddressTxt property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setSenderContactEmailAddressTxt(String value) {
        this.senderContactEmailAddressTxt = value;
    }

}
</code></pre>

<ol>
<li>Add code for ObjectFactory.java</li>
</ol>

<pre><code>//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 
// See &lt;a href="http://java.sun.com/xml/jaxb"&gt;http://java.sun.com/xml/jaxb&lt;/a&gt; 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2014.11.05 at 11:20:51 AM EST 
//


package fatca.idessenderfilemetadata;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlElementDecl;
import javax.xml.bind.annotation.XmlRegistry;
import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.namespace.QName;


/**
 * This object contains factory methods for each 
 * Java content interface and Java element interface 
 * generated in the fatca.idessenderfilemetadata package. 
 * &lt;p&gt;An ObjectFactory allows you to programatically 
 * construct new instances of the Java representation 
 * for XML content. The Java representation of XML 
 * content can consist of schema derived interfaces 
 * and classes representing the binding of schema 
 * type definitions, element declarations and model 
 * groups.  Factory methods for each of these are 
 * provided in this class.
 * 
 */
@XmlRegistry
public class ObjectFactory {

    private final static QName _SenderFileId_QNAME = new QName("urn:fatca:idessenderfilemetadata", "SenderFileId");
    private final static QName _FATCAEntCommunicationTypeCd_QNAME = new QName("urn:fatca:idessenderfilemetadata", "FATCAEntCommunicationTypeCd");
    private final static QName _TaxYear_QNAME = new QName("urn:fatca:idessenderfilemetadata", "TaxYear");
    private final static QName _FileRevisionInd_QNAME = new QName("urn:fatca:idessenderfilemetadata", "FileRevisionInd");
    private final static QName _FATCAIDESSenderFileMetadata_QNAME = new QName("urn:fatca:idessenderfilemetadata", "FATCAIDESSenderFileMetadata");
    private final static QName _SenderContactEmailAddressTxt_QNAME = new QName("urn:fatca:idessenderfilemetadata", "SenderContactEmailAddressTxt");
    private final static QName _FATCAEntitySenderId_QNAME = new QName("urn:fatca:idessenderfilemetadata", "FATCAEntitySenderId");
    private final static QName _FATCAEntityReceiverId_QNAME = new QName("urn:fatca:idessenderfilemetadata", "FATCAEntityReceiverId");
    private final static QName _OriginalIDESTransmissionId_QNAME = new QName("urn:fatca:idessenderfilemetadata", "OriginalIDESTransmissionId");
    private final static QName _FileCreateTs_QNAME = new QName("urn:fatca:idessenderfilemetadata", "FileCreateTs");

    /**
     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fatca.idessenderfilemetadata
     * 
     */
    public ObjectFactory() {
    }

    /**
     * Create an instance of {@link FATCAIDESSenderFileMetadataType }
     * 
     */
    public FATCAIDESSenderFileMetadataType createFATCAIDESSenderFileMetadataType() {
        return new FATCAIDESSenderFileMetadataType();
    }

    /**
     * Create an instance of {@link JAXBElement }{@code &lt;}{@link String }{@code &gt;}}
     * 
     */
    @XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "SenderFileId")
    public JAXBElement&lt;String&gt; createSenderFileId(String value) {
        return new JAXBElement&lt;String&gt;(_SenderFileId_QNAME, String.class, null, value);
    }

    /**
     * Create an instance of {@link JAXBElement }{@code &lt;}{@link FATCAEntCommunicationTypeCdType }{@code &gt;}}
     * 
     */
    @XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "FATCAEntCommunicationTypeCd")
    public JAXBElement&lt;FATCAEntCommunicationTypeCdType&gt; createFATCAEntCommunicationTypeCd(FATCAEntCommunicationTypeCdType value) {
        return new JAXBElement&lt;FATCAEntCommunicationTypeCdType&gt;(_FATCAEntCommunicationTypeCd_QNAME, FATCAEntCommunicationTypeCdType.class, null, value);
    }

    /**
     * Create an instance of {@link JAXBElement }{@code &lt;}{@link XMLGregorianCalendar }{@code &gt;}}
     * 
     */
    @XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "TaxYear")
    public JAXBElement&lt;XMLGregorianCalendar&gt; createTaxYear(XMLGregorianCalendar value) {
        return new JAXBElement&lt;XMLGregorianCalendar&gt;(_TaxYear_QNAME, XMLGregorianCalendar.class, null, value);
    }

    /**
     * Create an instance of {@link JAXBElement }{@code &lt;}{@link Boolean }{@code &gt;}}
     * 
     */
    @XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "FileRevisionInd")
    public JAXBElement&lt;Boolean&gt; createFileRevisionInd(Boolean value) {
        return new JAXBElement&lt;Boolean&gt;(_FileRevisionInd_QNAME, Boolean.class, null, value);
    }

    /**
     * Create an instance of {@link JAXBElement }{@code &lt;}{@link FATCAIDESSenderFileMetadataType }{@code &gt;}}
     * 
     */
    @XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "FATCAIDESSenderFileMetadata")
    public JAXBElement&lt;FATCAIDESSenderFileMetadataType&gt; createFATCAIDESSenderFileMetadata(FATCAIDESSenderFileMetadataType value) {
        return new JAXBElement&lt;FATCAIDESSenderFileMetadataType&gt;(_FATCAIDESSenderFileMetadata_QNAME, FATCAIDESSenderFileMetadataType.class, null, value);
    }

    /**
     * Create an instance of {@link JAXBElement }{@code &lt;}{@link String }{@code &gt;}}
     * 
     */
    @XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "SenderContactEmailAddressTxt")
    public JAXBElement&lt;String&gt; createSenderContactEmailAddressTxt(String value) {
        return new JAXBElement&lt;String&gt;(_SenderContactEmailAddressTxt_QNAME, String.class, null, value);
    }

    /**
     * Create an instance of {@link JAXBElement }{@code &lt;}{@link String }{@code &gt;}}
     * 
     */
    @XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "FATCAEntitySenderId")
    public JAXBElement&lt;String&gt; createFATCAEntitySenderId(String value) {
        return new JAXBElement&lt;String&gt;(_FATCAEntitySenderId_QNAME, String.class, null, value);
    }

    /**
     * Create an instance of {@link JAXBElement }{@code &lt;}{@link String }{@code &gt;}}
     * 
     */
    @XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "FATCAEntityReceiverId")
    public JAXBElement&lt;String&gt; createFATCAEntityReceiverId(String value) {
        return new JAXBElement&lt;String&gt;(_FATCAEntityReceiverId_QNAME, String.class, null, value);
    }

    /**
     * Create an instance of {@link JAXBElement }{@code &lt;}{@link String }{@code &gt;}}
     * 
     */
    @XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "OriginalIDESTransmissionId")
    public JAXBElement&lt;String&gt; createOriginalIDESTransmissionId(String value) {
        return new JAXBElement&lt;String&gt;(_OriginalIDESTransmissionId_QNAME, String.class, null, value);
    }

    /**
     * Create an instance of {@link JAXBElement }{@code &lt;}{@link String }{@code &gt;}}
     * 
     */
    @XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "FileCreateTs")
    public JAXBElement&lt;String&gt; createFileCreateTs(String value) {
        return new JAXBElement&lt;String&gt;(_FileCreateTs_QNAME, String.class, null, value);
    }

}
</code></pre>

<ol>
<li>Add code for package-info.java</li>
</ol>

<pre><code>//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 
// See &lt;a href="http://java.sun.com/xml/jaxb"&gt;http://java.sun.com/xml/jaxb&lt;/a&gt; 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2014.11.05 at 11:20:51 AM EST 
//

@javax.xml.bind.annotation.XmlSchema(namespace = "urn:fatca:idessenderfilemetadata", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package fatca.idessenderfilemetadata;

</code></pre>

<h2>
<a id="keystore" class="anchor" href="#keystore" aria-hidden="true"><span class="octicon octicon-link"></span></a>Keystore</h2>

<p>Place the Keystore folder from the repository .zip file into the IDESDataPreparation folder. This will contain the test keys that the program will use. </p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image7.png" alt="Image 7"><br>
Figure 7  </p>

<h2>
<a id="lib-folder" class="anchor" href="#lib-folder" aria-hidden="true"><span class="octicon octicon-link"></span></a>lib folder</h2>

<p>Place the lib folder from the repository .zip file into the IDESDataPreparation folder. This will contain the .jar file for the console logging functionality.</p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image8.png" alt="Image 8"><br>
Figure 8  </p>

<h2>
<a id="src-folder" class="anchor" href="#src-folder" aria-hidden="true"><span class="octicon octicon-link"></span></a>src folder</h2>

<p>Add the src folder from the .zip repository or replicate the folder structure below. 
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image9.png" alt="Image 9"><br>
Figure 9</p>

<ol>
<li>Add code for FATCAPackager.java</li>
</ol>

<pre><code>package fatca;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.net.URI;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.Enumeration;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.Deflater;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.datatype.DatatypeConstants;
import javax.xml.datatype.XMLGregorianCalendar;

import org.apache.log4j.Logger;

import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;

import fatca.idessenderfilemetadata.FATCAEntCommunicationTypeCdType;
import fatca.idessenderfilemetadata.FATCAIDESSenderFileMetadataType;

public class FATCAPackager {
    public static String AES_TRANSFORMATION = "AES/ECB/PKCS5Padding";
    public static String RSA_TRANSFORMATION = "RSA";
    public static String SECRET_KEY_ALGO = "AES";
    public static int SECRET_KEY_SIZE = 256;

    public static String metadataEmailAddress="none@email.com";
    public static int bufSize = 64 * 1024;

    public static boolean isCanonicalization = true;

    protected static Logger logger = Logger.getLogger(new Object(){}.getClass().getEnclosingClass().getName());

    protected FATCAXmlSigner signer = new FATCAXmlSigner();
    protected Long fileId = 0L;
    protected fatca.idessenderfilemetadata.ObjectFactory objFMetadata = new fatca.idessenderfilemetadata.ObjectFactory();
    protected SimpleDateFormat sdfFileName = new SimpleDateFormat("yyyyMMdd'T'HHmmssSSS'Z'");
    protected SimpleDateFormat sdfFileCreateTs = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");

    protected int maxAttempts = 5;

    protected boolean aes(int opmode, String inputFile, String outputFile, SecretKey secretKey) throws Exception {
        logger.debug("--&gt; aes(). opmode=" + (opmode==Cipher.ENCRYPT_MODE?"ENCRYPT":"DECRYPT") + 
            ", inputFile=" + inputFile + ", outputFile=" + outputFile);
        if (opmode != Cipher.ENCRYPT_MODE &amp;&amp; opmode != Cipher.DECRYPT_MODE)
            throw new Exception("Invalid opmode " + opmode + ". Allowed opmodes are Cipher.ENCRYPT_MODE or Cipher.DECRYPT_MODE");
        boolean ret = false;
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        int len;
        byte[] output = null;
        byte[] buf = new byte[bufSize];
        Cipher cipher;
        try {
            cipher = Cipher.getInstance(AES_TRANSFORMATION);
            cipher.init(opmode, secretKey);
            bis = new BufferedInputStream(new FileInputStream(inputFile));
            bos = new BufferedOutputStream(new FileOutputStream(outputFile));
            while((len = bis.read(buf)) != -1) {
                //output = cipher.update(Arrays.copyOf(buf, len));
                output = cipher.update(buf, 0, len);
                if (output.length &gt; 0)
                    bos.write(output);
            }
            output = cipher.doFinal();
            if (output.length &gt; 0)
                bos.write(output);
            bos.close(); bos = null;
            bis.close(); bis = null; 
            ret = true;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        } finally {
            if (bis != null) try{bis.close();}catch(Exception e) {}
            if (bos != null) try{bos.close();}catch(Exception e) {}
        }
        logger.debug("&lt;-- aes()");
        return ret;
    }

    protected boolean encrypt(String zippedSignedPlainTextFile, String cipherTextOutFile, Certificate[] receiversPublicCert,
            String[] encryptedAESKeyOutFiles) throws Exception {
        logger.debug("--&gt; encrypt(). zippedSignedPlainTextFile=" + zippedSignedPlainTextFile + ", cipherTextOutFile=" + cipherTextOutFile);
        PublicKey[] pubkeys = new PublicKey[receiversPublicCert.length];
        for (int i = 0; i &lt; receiversPublicCert.length; i++)
            pubkeys[i] = receiversPublicCert[i].getPublicKey();
        boolean flag = encrypt(zippedSignedPlainTextFile, cipherTextOutFile, pubkeys, encryptedAESKeyOutFiles);
        logger.debug("&lt;-- encrypt()");
        return flag;
    }

    protected boolean encrypt(String zippedSignedPlainTextFile, String cipherTextOutFile, PublicKey[] receiversPublicKey,
            String[] encryptedAESKeyOutFiles) throws Exception {
        logger.debug("--&gt; encrypt(). zippedSignedPlainTextFile=" + zippedSignedPlainTextFile + ", cipherTextOutFile" + cipherTextOutFile);
        boolean ret = false;
        SecretKey skey = null;
        KeyGenerator generator;
        byte[] encryptedAESKeyBuf;
        BufferedOutputStream bos = null;
        Cipher cipher = null;
        try {
            generator = KeyGenerator.getInstance(SECRET_KEY_ALGO);
            generator.init(SECRET_KEY_SIZE);
            skey = generator.generateKey();
            ret = aes(Cipher.ENCRYPT_MODE, zippedSignedPlainTextFile, cipherTextOutFile, skey);
            if (ret) {
                for (int i = 0; i &lt; receiversPublicKey.length &amp;&amp; i &lt; encryptedAESKeyOutFiles.length; i++) {
                    if (cipher == null)
                        cipher = Cipher.getInstance(RSA_TRANSFORMATION);
                    cipher.init(Cipher.WRAP_MODE, receiversPublicKey[i]);
                    encryptedAESKeyBuf = cipher.wrap(skey);
                    bos = new BufferedOutputStream(new FileOutputStream(encryptedAESKeyOutFiles[i]));
                    bos.write(encryptedAESKeyBuf);
                    bos.close(); bos = null;
                }
                ret = true;
            }
        } catch(Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        } finally {
            if (bos != null) try{bos.close();}catch(Exception e) {}
        }
        logger.debug("&lt;-- encrypt)");
        return ret;
    }

    protected boolean renameZipEntry(String zipFile, String entryName, String newEntryName) throws Exception {
        logger.debug("--&gt; renameZipEntry(). zipFile=" + zipFile + ", entryName=" + entryName + ", newEntryName=" + newEntryName);
        boolean ret = false;
        Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;(); 
        props.put("create", "false"); 
        try {
            URI zipDisk = URI.create("jar:" + new File(zipFile).toURI());
            FileSystem zipfs = FileSystems.newFileSystem(zipDisk, props);
            Path pathInZipfile = zipfs.getPath(entryName);
            Path renamedZipEntry = zipfs.getPath(newEntryName);
            Files.move(pathInZipfile,renamedZipEntry, StandardCopyOption.ATOMIC_MOVE);
            zipfs.close();
            ret = true;
        } catch(Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        }
        logger.debug("&lt;-- renameZipEntry()");
        return ret;
    }

    protected boolean renameZipEntries(String zipFile, String[] entryNames, String[] newEntryNames) throws Exception {
        if (logger.isDebugEnabled()) {
            StringBuilder sb = new StringBuilder("--&gt; renameZipEntries()");
            sb.append(", zipFile=");
            sb.append(zipFile);
            sb.append(", entryNames=[");
            for (int i = 0; i &lt; entryNames.length; i++) {
                if (i &gt; 0) sb.append(",");
                sb.append(entryNames[i]);
            }
            sb.append("], newEntryNames=[");
            for (int i = 0; i &lt; newEntryNames.length; i++) {
                if (i &gt; 0) sb.append(",");
                sb.append(newEntryNames[i]);
            }
            sb.append("]");
            logger.debug(sb.toString());
        }
        boolean ret = false;
        if (entryNames.length != newEntryNames.length)
            throw new Exception("renameZipEntries entryNames and newEntryNames length should be same");
        Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;(); 
        props.put("create", "false"); 
        try {
            URI zipDisk = URI.create("jar:" + new File(zipFile).toURI());
            FileSystem zipfs = FileSystems.newFileSystem(zipDisk, props);
            Path pathInZipfile, renamedZipEntry;
            for (int i = 0; i &lt; entryNames.length; i++) {
                pathInZipfile = zipfs.getPath(entryNames[i]);
                renamedZipEntry = zipfs.getPath(newEntryNames[i]);
                Files.move(pathInZipfile,renamedZipEntry, StandardCopyOption.ATOMIC_MOVE);
            }
            zipfs.close();
            ret = true;
        } catch(Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        }
        logger.debug("&lt;-- renameZipEntries()");
        return ret;
    }

    protected boolean createZipFile(String[] inFiles, String outFile) throws Exception {
        if (logger.isDebugEnabled()) {
            StringBuilder sb = new StringBuilder("--&gt; createZipFile()");
            sb.append(", inFiles=[");
            for (int i = 0; i &lt; inFiles.length; i++) {
                if (i &gt; 0) sb.append(",");
                sb.append(inFiles[i]);
            }
            sb.append("], outFile=");
            sb.append(outFile);
            logger.debug(sb.toString());
        }
        BufferedInputStream bis = null;
        ZipOutputStream zos = null;
        ZipEntry zipEntry;
        int len;
        boolean ret = false;
        String infile;
        byte[] buf = new byte[bufSize];
        try {
            zos = new ZipOutputStream(new FileOutputStream(outFile));
            zos.setLevel(Deflater.BEST_COMPRESSION);
            for (int i = 0; i &lt; inFiles.length; i++) {
                // drop folder names
                infile = inFiles[i];
                len = infile.lastIndexOf("/");
                if (len == -1)
                    len = infile.lastIndexOf("\\");
                if (len != -1)
                    infile = infile.substring(len+1);
                zipEntry = new ZipEntry(infile);
                zos.putNextEntry(zipEntry);
                bis = new BufferedInputStream(new FileInputStream(inFiles[i]));
                while((len = bis.read(buf)) != -1)
                    zos.write(buf, 0, len);
                bis.close(); bis = null;
                zos.closeEntry();
            }
            zos.close(); zos = null;
            ret = true;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        } finally {
            if (bis != null) try{bis.close();}catch(Exception e) {}
            if (zos != null) try{zos.close();}catch(Exception e) {}
        }
        logger.debug("&lt;-- createZipFile()");
        return ret;
    }

    protected ArrayList&lt;String&gt; unzipFile(String inFile) throws Exception {
        return unzipFile(inFile, null);
    }

    protected ArrayList&lt;String&gt; unzipFile(String inFile, String extractFolder) throws Exception {
        logger.debug("--&gt; unzipFile(). inFile=" + inFile + ", extractFolder=" + extractFolder);
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        int len;
        ZipFile zipFile = null;
        Enumeration&lt;? extends ZipEntry&gt; entries;
        ZipEntry entry;
        ArrayList&lt;String&gt; entryList = null;
        byte[] buf = new byte[bufSize];
        String outFile;
        try {
            if (extractFolder == null)
                extractFolder = ".";
            if (!extractFolder.endsWith("/") &amp;&amp; !extractFolder.endsWith("\\"))
                extractFolder += "/";
            zipFile = new ZipFile(inFile);
            entries = zipFile.entries();
            while (entries.hasMoreElements()) {
                if (entryList == null)
                    entryList = new ArrayList&lt;String&gt;();
                entry = entries.nextElement();
                outFile = extractFolder + entry.getName();
                entryList.add(outFile);
                bis = new BufferedInputStream(zipFile.getInputStream(entry));
                bos = new BufferedOutputStream(new FileOutputStream(outFile));
                while((len = bis.read(buf)) != -1)
                    bos.write(buf, 0, len);
                bos.close(); bos = null;
                bis.close(); bis = null;
            }
            zipFile.close(); zipFile = null;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        } finally {
            if (bis != null) try{bis.close();}catch(Exception e) {}
            if (bos != null) try{bos.close();}catch(Exception e) {}
            if (zipFile != null) try{zipFile.close();}catch(Exception e) {}
        }
        logger.debug("&lt;-- unzipFile()");
        return entryList;
    }

    //_Payload.xml,_Metadata.xml, _Payload.zip, _Key, _Payload
    protected String getFileName(String senderGiin, String filename) throws Exception {
        synchronized (fileId) {
            logger.debug("--&gt; getFileName(). senderGiin=" + senderGiin + ", filename=" + filename);
            if (fileId == Long.MAX_VALUE) fileId = 0L;
            String xmlfilename = senderGiin + "_" + fileId++ + filename;
            File file = new File(xmlfilename);
            int attempts = maxAttempts;
            while(!file.createNewFile() &amp;&amp; attempts-- &gt; 0) {
                xmlfilename = senderGiin + "_" + fileId++ + filename;
                file = new File(xmlfilename);
            }
            if (attempts &lt;= 0)
                throw new Exception ("Unable to getFileName() - file=" + file.getAbsolutePath());
            logger.debug("&lt;-- getFileName()");
            return xmlfilename;
        }
    }

    protected String getIDESFileName(String senderGiin) throws Exception {
        synchronized (fileId) {
            logger.debug("--&gt; getIDESFileName(). senderGiin=" + senderGiin);
            Date date = new Date();
            String outfile = sdfFileName.format(date) + "_" + senderGiin + ".zip";
            File file = new File(outfile);
            int attempts = maxAttempts;
            while (!file.createNewFile() &amp;&amp; attempts-- &gt; 0) {
                outfile = sdfFileName.format(new Date()) + "_" + senderGiin + ".zip";
                file = new File(outfile);
            }
            if (attempts &lt;= 0)
                throw new Exception ("Unable to getFileName() - file=" + file.getAbsolutePath());
            logger.debug("&lt;-- getIDESFileName()");
            return outfile;
        }
    }

    protected XMLGregorianCalendar genTaxYear(int year) {
        XMLGregorianCalendar taxyear = new XMLGregorianCalendarImpl(new GregorianCalendar());
        taxyear.setTimezone(DatatypeConstants.FIELD_UNDEFINED);
        taxyear.setTime(DatatypeConstants.FIELD_UNDEFINED, DatatypeConstants.FIELD_UNDEFINED, DatatypeConstants.FIELD_UNDEFINED);
        taxyear.setDay(DatatypeConstants.FIELD_UNDEFINED);
        taxyear.setMonth(DatatypeConstants.FIELD_UNDEFINED);
        taxyear.setYear(year);
        return taxyear;
    }

    protected String getFileName(String filename) {
        File f = new File(filename);
        return f.getName();
    }

    public String signAndCreatePkg(String unsignedXml, PrivateKey senderPrivateKey, X509Certificate senderPublicCert,
            String senderGiin, String receiverGiin, X509Certificate receiverPublicCert, int taxyear) throws Exception {
        logger.debug("--&gt; signAndCreatePkg(). unsignedXml=" + unsignedXml + ", senderGiin=" + senderGiin +
                ", receiverGiin=" + receiverGiin + ", taxyear=" + taxyear);
        String signedxml = unsignedXml + ".signed";
        boolean success = false;
        String ret = null;
        if (isCanonicalization)
            success = signer.signStreamingWithCanonicalization(unsignedXml, signedxml, senderPrivateKey, senderPublicCert);
        else
            success = signer.signStreaming(unsignedXml, signedxml, senderPrivateKey, senderPublicCert);
        if (success)
            ret = createPkgWithApprover(signedxml, senderGiin, receiverGiin, receiverPublicCert, null, null, taxyear);
        logger.debug("&lt;-- signAndCreatePkg()");
        return ret;
    }

    public String signAndCreatePkgWithApprover(String unsignedxml, PrivateKey senderPrivateKey, X509Certificate senderPublicCert,
            String senderGiin, String receiverGiin, X509Certificate receiverPublicCert, String approverGiin, 
            X509Certificate approvercert, int taxyear) throws Exception {
        logger.debug("--&gt; signAndCreatePkgWithApprover(). xmlfilename=" + unsignedxml + ", senderGiin=" + senderGiin +
                ", receiverGiin=" + receiverGiin + ", approverGiin=" + approverGiin + ", taxyear=" + taxyear);
        String signedxml = unsignedxml + ".signed";
        boolean success = false;
        String ret = null;
        if (isCanonicalization)
            success = signer.signStreamingWithCanonicalization(unsignedxml, signedxml, senderPrivateKey, senderPublicCert);
        else
            success = signer.signStreaming(unsignedxml, signedxml, senderPrivateKey, senderPublicCert);
        if (success)
            ret = createPkgWithApprover(signedxml, senderGiin, receiverGiin, receiverPublicCert, approverGiin, approvercert, taxyear);
        logger.debug("&lt;-- signAndCreatePkgWithApprover()");
        return ret;
    }

    public String createPkg(String signedXmlFile, String senderGiin, String receiverGiin,  
            X509Certificate receiverPublicCert, int taxyear) throws Exception {
        return createPkgWithApprover(signedXmlFile, senderGiin, receiverGiin, receiverPublicCert, null, null, taxyear);
    }

    public String createPkgWithApprover(String signedXmlFile, String senderGiin, String receiverGiin,  
            X509Certificate receiverPublicCert, String approverGiin, 
            X509Certificate approvercert, int taxyear) throws Exception {
        logger.debug("--&gt; createPkgWithApprover(). signedXmlFile= " + signedXmlFile + ", senderGiin=" + senderGiin + 
                ", receiverGiin=" + receiverGiin + ", approverGiin=" + approverGiin);
        String idesOutFile = null;
        try {
            Date date = new Date();
            String metadatafile = getFileName(senderGiin, "_Metadata.xml");
            JAXBContext jaxbCtxMetadata = JAXBContext.newInstance(FATCAIDESSenderFileMetadataType.class);            
            Marshaller mrshler = jaxbCtxMetadata.createMarshaller();
            mrshler.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);

            FATCAIDESSenderFileMetadataType metadata = objFMetadata.createFATCAIDESSenderFileMetadataType();
            JAXBElement&lt;FATCAIDESSenderFileMetadataType&gt; jaxbElemMetadata = objFMetadata.createFATCAIDESSenderFileMetadata(metadata);

            metadata.setFATCAEntCommunicationTypeCd(FATCAEntCommunicationTypeCdType.RPT);
            metadata.setFATCAEntitySenderId(senderGiin);
            metadata.setFileRevisionInd(false);
            String senderFileId = getIDESFileName(senderGiin);
            File file = new File(senderFileId);
            metadata.setSenderFileId(file.getName());
            metadata.setTaxYear(genTaxYear(taxyear));
            metadata.setFATCAEntityReceiverId(receiverGiin);
            metadata.setFileCreateTs(sdfFileCreateTs.format(date));
            metadata.setSenderContactEmailAddressTxt(metadataEmailAddress);
            FileWriter fw = new FileWriter(metadatafile);
            mrshler.marshal(jaxbElemMetadata, fw);
            fw.close();
            String xmlzipFilename;
            boolean success = false;
            xmlzipFilename = getFileName(senderGiin, "_Payload.zip");
            success = createZipFile(new String[]{signedXmlFile}, xmlzipFilename);
            if (success)
                success = renameZipEntry(xmlzipFilename, getFileName(signedXmlFile), senderGiin + "_Payload.xml");
            if (!success)
                throw new Exception("uanble to create " + xmlzipFilename);
            idesOutFile = senderFileId;
            Certificate[] certs = null;
            String[] encryptedAESKeyOutFiles = null;
            if (approvercert != null &amp;&amp; approverGiin != null) {
                certs = new X509Certificate[] {receiverPublicCert, approvercert};
                encryptedAESKeyOutFiles = new String[]{getFileName(receiverGiin, "_Key"), getFileName(approverGiin, "_Key")};
            } else if (receiverPublicCert != null){
                certs = new X509Certificate[] {receiverPublicCert};
                encryptedAESKeyOutFiles = new String[]{getFileName(receiverGiin, "_Key")};
            } else
                throw new Exception ("both approvingEntityCert and receivingEntityCert is null");
            String xmlZippedEncryptedFile = getFileName(senderGiin, "_Payload");
            success = encrypt(xmlzipFilename, xmlZippedEncryptedFile, certs, encryptedAESKeyOutFiles);
            if (! success)
                throw new Exception("encryption failed. xmlzipFilename=" + xmlzipFilename);
            int count = 0;
            String[] infiles = new String[encryptedAESKeyOutFiles.length + 2];
            for (count = 0; count &lt; encryptedAESKeyOutFiles.length; count++)
                infiles[count] = encryptedAESKeyOutFiles[count];
            infiles[count++] =  xmlZippedEncryptedFile;
            infiles[count] = metadatafile;
            success = createZipFile(infiles, idesOutFile);
            if (success) {
                if (encryptedAESKeyOutFiles.length == 2)
                    success = renameZipEntries(idesOutFile, new String[]{getFileName(xmlZippedEncryptedFile), getFileName(metadatafile), 
                            getFileName(encryptedAESKeyOutFiles[0]), getFileName(encryptedAESKeyOutFiles[1])},
                            new String[]{senderGiin + "_Payload", senderGiin + "_Metadata.xml", 
                            receiverGiin + "_Key", approverGiin + "_Key"});
                else
                    success = renameZipEntries(idesOutFile, new String[]{getFileName(xmlZippedEncryptedFile), getFileName(metadatafile), 
                        getFileName(encryptedAESKeyOutFiles[0])},
                        new String[]{senderGiin + "_Payload", senderGiin + "_Metadata.xml", 
                        receiverGiin + "_Key"});
            }
            if (!success)
                throw new Exception("unable to create zip file " + idesOutFile);
            for (int i = 0; i &lt; infiles.length; i++)
                deleteFile(infiles[i]);
            deleteFile(xmlzipFilename);
            //deleteFile(signedXmlFile);
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        }
        logger.debug("&lt;-- createPkgWithApprover()");
        return idesOutFile;
    }

    protected boolean decrypt(String cipherTextFile, String encryptedAESKeyFile, String zippedSignedPlainTextFile, PrivateKey privkey) throws Exception {
        logger.debug("--&gt; decrypt(). cipherTextFile= " + cipherTextFile + ", encryptedAESKeyFile=" + encryptedAESKeyFile + 
                ", zippedSignedPlainTextFile=" + zippedSignedPlainTextFile);
        SecretKey skey;
        boolean ret = false;
        BufferedInputStream bis = null;
        byte[] buf, skeyBuf = null;
        int len, count;
        try {
            buf = new byte[bufSize];
            bis = new BufferedInputStream(new FileInputStream(encryptedAESKeyFile));
            while((len = bis.read(buf)) != -1) {
                if (skeyBuf == null) {
                    skeyBuf = new byte[len];
                    System.arraycopy(buf, 0, skeyBuf, 0, len);
                } else {
                    count = skeyBuf.length;
                    skeyBuf = Arrays.copyOf(skeyBuf, skeyBuf.length + len);
                    System.arraycopy(buf, 0, skeyBuf, count, len);
                }
            }
            bis.close(); bis = null;
            Cipher cipher = Cipher.getInstance(RSA_TRANSFORMATION);
            cipher.init(Cipher.UNWRAP_MODE, privkey);
            skey = (SecretKey)cipher.unwrap(skeyBuf, SECRET_KEY_ALGO, Cipher.SECRET_KEY);
            ret = aes(Cipher.DECRYPT_MODE, cipherTextFile, zippedSignedPlainTextFile, skey);
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        } finally {
            if (bis != null) try{bis.close();}catch(Exception e) {}
        }
        logger.debug("&lt;-- createPkgWithApprover()");
        return ret;
    }

    protected void deleteFile(String filename) {
        File file = new File(filename);
        int attempts = maxAttempts;
        while (file.exists() &amp;&amp; !file.delete() &amp;&amp; attempts--&gt;0)
            Thread.yield();
    }

    public boolean unpack(String idesPkgFile, String keystoreType, String keystoreFile, String keystorePwd, String keyPwd, String keyAlias) throws Exception {
        logger.debug("--&gt; unpack(). idesPkgFile=" + idesPkgFile + ", keystoreType=" + keystoreType + 
                ", keystoreFile=" + keystoreFile + ", keyAlias=" + keyAlias);
        PrivateKey privateKey = UtilShared.getPrivateKey(keystoreType, keystoreFile, keystorePwd, keyPwd, keyAlias);
        boolean flag = unpack (idesPkgFile, privateKey);
        logger.debug("&lt;-- unpack()");
        return flag;
    }

    public boolean unpack(String idesPkgFile, PrivateKey receiverPrivateKey) throws Exception {
        logger.debug("--&gt; unpack(). idesPkgFile=" + idesPkgFile);
        boolean flag = unpack(idesPkgFile, receiverPrivateKey, false);
        logger.debug("&lt;-- unpack()");
        return flag;
    }

    public boolean unpackForApprover(String idesPkgFile, String approverKeystoreType, String approverKeystoreFile, 
            String approverKeystorePwd, String approverKeyPwd, String approverKeyAlias) throws Exception {
        logger.debug("--&gt; unpackForApprover(). idesPkgFile=" + idesPkgFile + ", approverKeystoreType=" + approverKeystoreType + 
                ", approverKeystoreFile=" + approverKeystoreFile + ", approverKeyAlias=" + approverKeyAlias);
        PrivateKey approverPrivateKey = UtilShared.getPrivateKey(approverKeystoreType, approverKeystoreFile, approverKeystorePwd, approverKeyPwd, approverKeyAlias);
        boolean flag = unpackForApprover(idesPkgFile, approverPrivateKey);
        logger.debug("&lt;-- unpackForApprover()");
        return flag;
    }

    public boolean unpackForApprover(String idesPkgFile, PrivateKey approverPrivateKey) throws Exception {
        logger.debug("--&gt; unpackForApprover(). idesPkgFile=" + idesPkgFile);
        boolean flag = unpack(idesPkgFile, approverPrivateKey, true);
        logger.debug("&lt;-- unpackForApprover()");
        return flag;
    }

    protected boolean unpack(String idesPkgFile, PrivateKey privateKey, boolean isApprover) throws Exception {
        logger.debug("--&gt; unpack(). idesPkg=" + idesPkgFile + ", isApprover=" + isApprover);
        boolean ret = false;
        try {
            ArrayList&lt;String&gt; entryList = unzipFile(idesPkgFile);
            String approverKeyFile = null, receiverKeyFile = null, payloadFile = null, metadataFile = null,  receiverGiin = null, filename;
            // get metadata file
            for (int i = 0; i &lt; entryList.size(); i++) {
                filename = entryList.get(i);
                if (filename.contains("Metadata"))
                    metadataFile = filename;
                else if (filename.contains("Payload"))
                    payloadFile = filename;
                else if (filename.contains("Key")) {
                    if (receiverKeyFile == null)
                        receiverKeyFile = filename;
                    else
                        approverKeyFile = filename;
                }
            }
            if (metadataFile == null)
                throw new Exception("Invalid package - no metadata file");
            if (payloadFile == null)
                throw new Exception("Invalid package - no payload file");

            if (approverKeyFile != null) {
                JAXBContext jaxbCtxMetadata = JAXBContext.newInstance("fatca.idessenderfilemetadata");
                Unmarshaller unmrshlr = jaxbCtxMetadata.createUnmarshaller();
                Object obj = unmrshlr.unmarshal(new File(metadataFile));;
                if (obj instanceof JAXBElement&lt;?&gt;) {
                    @SuppressWarnings("unchecked")
                    JAXBElement&lt;FATCAIDESSenderFileMetadataType&gt; jaxbElem = 
                        (JAXBElement&lt;FATCAIDESSenderFileMetadataType&gt;)obj;
                    FATCAIDESSenderFileMetadataType metadataObj = jaxbElem.getValue();
                    receiverGiin = metadataObj.getFATCAEntityReceiverId();
                    if (!receiverKeyFile.contains(receiverGiin)) {
                        filename = approverKeyFile;
                        approverKeyFile = receiverKeyFile;
                        receiverKeyFile = filename;
                    }
                }
            } else if (receiverKeyFile != null)
                receiverGiin = receiverKeyFile.substring(0, receiverKeyFile.length() - "_Key".length());
            if (receiverGiin == null)
                throw new Exception("Invalid metadata file - missing receiver giin or corrupt zip file - no reveiverKeyFile");
            if (isApprover &amp;&amp; approverKeyFile == null)
                throw new Exception("Invalid package - no approverKeyFile");
            String zippedSignedPlainTextFile = getFileName(receiverGiin, "_Payload.zip");
            if (approverKeyFile != null &amp;&amp; isApprover)
                ret = decrypt(payloadFile, approverKeyFile, zippedSignedPlainTextFile, privateKey);
            else
                ret = decrypt(payloadFile, receiverKeyFile, zippedSignedPlainTextFile, privateKey);

            if (ret) {
                if (unzipFile(zippedSignedPlainTextFile) == null)
                    ret = false;
                else
                    deleteFile(zippedSignedPlainTextFile);
            }
            deleteFile(payloadFile);
            //deleteFile(metadataFile);
            deleteFile(receiverKeyFile);
            if (approverKeyFile != null)
                deleteFile(approverKeyFile);
        } catch(Exception e) {
            logger.error(e.getMessage());
            throw e;
        }
        logger.debug("&lt;-- unpack()");
        return ret;
    }
}
</code></pre>

<ol>
<li>Add code for FATCAXmlSigner.java</li>
</ol>

<pre><code>package fatca;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.Signature;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import javax.xml.XMLConstants;
import javax.xml.crypto.XMLStructure;
import javax.xml.crypto.dom.DOMStructure;
import javax.xml.crypto.dsig.CanonicalizationMethod;
import javax.xml.crypto.dsig.DigestMethod;
import javax.xml.crypto.dsig.Reference;
import javax.xml.crypto.dsig.SignedInfo;
import javax.xml.crypto.dsig.XMLObject;
import javax.xml.crypto.dsig.XMLSignature;
import javax.xml.crypto.dsig.XMLSignatureFactory;
import javax.xml.crypto.dsig.dom.DOMSignContext;
import javax.xml.crypto.dsig.keyinfo.KeyInfo;
import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;
import javax.xml.crypto.dsig.keyinfo.X509Data;
import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;
import javax.xml.crypto.dsig.spec.TransformParameterSpec;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.sun.org.apache.xml.internal.security.Init;
import com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;
import com.sun.org.apache.xml.internal.security.utils.Base64;
import com.sun.org.apache.xml.internal.security.utils.IgnoreAllErrorHandler;

import java.io.FileReader;
import java.io.StringReader;
import org.xml.sax.InputSource;
import org.xml.sax.SAXParseException;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamReader;
import java.util.Arrays;
import java.io.BufferedReader;
import javax.xml.namespace.QName;

public class FATCAXmlSigner {
    public static String SIGNATURE_OBJECT_ID = "FATCA";
    public static String SIGNATUER_ALGO = "SHA256withRSA";
    public static String MESSAGE_DIGEST_ALGO = "SHA-256";
    public static String SIGNATURE_DIGEST_METHOD = DigestMethod.SHA256;
    public static String SIGNATURE_METHOD = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256";
    public static String CANONICALIZATION_METHOD = CanonicalizationMethod.INCLUSIVE;

    public static int bufSize = 64 * 1024;

    protected static Logger logger = Logger.getLogger(new Object(){}.getClass().getEnclosingClass().getName());
    protected static int logLevel = logger.getEffectiveLevel().toInt();
    protected static String digprefix = "&lt;Object xmlns=\"http://www.w3.org/2000/09/xmldsig#\" Id=\"" + SIGNATURE_OBJECT_ID + "\"&gt;";
    protected static String digsuffix = "&lt;/Object&gt;";
    protected static final int STARTTAG = 0;
    protected static final int ENDTAG = 1;
    protected static final int CHUNK = 2;

    public boolean useStrmXmlDigestCalcOption1OptionA = true;
    protected ArrayList&lt;String&gt; xmlChunkToCalcDigest = new ArrayList&lt;String&gt;(Arrays.asList(
            "MessageSpec", "ReportingFI", "Sponsor", "Intermediary", "AccountReport", "PoolReport"));

    // for debug
    public StringBuilder digestBuf  = null;

    protected XMLSignatureFactory xmlSigFactory = null;
    protected KeyInfoFactory keyInfoFactory = null;
    protected TransformerFactory transformerFactory = null;
    protected SAXParserFactory saxFactory = null;  
    protected Canonicalizer canonicalizer =  null;
    protected DocumentBuilder docBuilder = null;

    protected String digestValue = null, signatureValue = null;
    protected MessageDigest messageDigest = null;
    protected ArrayList&lt;String&gt; nsStartTagList = new ArrayList&lt;String&gt;();
    protected ArrayList&lt;String&gt; nsEndTagList = new ArrayList&lt;String&gt;();

    public FATCAXmlSigner() {
        try {
            Init.init();
            transformerFactory = TransformerFactory.newInstance();
            saxFactory = SAXParserFactory.newInstance();  
            xmlSigFactory = XMLSignatureFactory.getInstance();
            keyInfoFactory = xmlSigFactory.getKeyInfoFactory();
            saxFactory.setNamespaceAware(false);
            canonicalizer = Canonicalizer.getInstance(CANONICALIZATION_METHOD);
            DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();
            dfactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE);
            dfactory.setNamespaceAware(true);
            dfactory.setValidating(true);
            docBuilder = dfactory.newDocumentBuilder();
            docBuilder.setErrorHandler(new IgnoreAllErrorHandler());
        } catch(Exception e) {
            logger.error(e.getMessage(), e);
            throw new RuntimeException(e);
        }
    }

    protected void initMessageDigest() throws NoSuchAlgorithmException {
        logger.debug("--&gt; initMessageDigest()");
        digestValue = null;
        messageDigest = MessageDigest.getInstance(MESSAGE_DIGEST_ALGO);
        messageDigest.update(digprefix.getBytes());
        if (logLevel &lt;= Level.DEBUG_INT &amp;&amp; digestBuf != null) {
            digestBuf.setLength(0);
            digestBuf.append(digprefix);
        }
        logger.debug("&lt;-- initMessageDigest()");
    }

    protected void finalizeMessageDigest() {
        logger.debug("--&gt; finalizeMessageDigest()");
        messageDigest.update(digsuffix.getBytes());
        digestValue = Base64.encode(messageDigest.digest());
        if (logLevel &lt;= Level.DEBUG_INT &amp;&amp; digestBuf != null)
            digestBuf.append(digsuffix);
        logger.debug("&lt;-- finalizeMessageDigest()");
    }

    protected void calcMsgDigestByParsingDoc(String infile) throws Exception {
        logger.debug("--&gt; calcMsgDigestByParsingDoc(). infile=" + infile);
        boolean isStartTag = false, isXmlTagClosed = true;
        StringBuilder parseBuf = new StringBuilder();
        QName qname = null;
        String prefix, tag, qnameS, lastStartTag = null;
        XMLStreamReader reader = null;
        boolean isXmlChunkToCalcDigest = false;
        DocumentBuilder docBuilderNSTrue = null, docBuilderNSFalse = null;
        try {
            DocumentBuilderFactory dbfNSTrue = DocumentBuilderFactory.newInstance();
            dbfNSTrue.setNamespaceAware(true);
            DocumentBuilderFactory dbfNSFalse = DocumentBuilderFactory.newInstance();
            dbfNSFalse.setNamespaceAware(false);

            Canonicalizer canonicalizer = Canonicalizer.getInstance(CANONICALIZATION_METHOD);
            docBuilderNSTrue = dbfNSTrue.newDocumentBuilder();
            docBuilderNSTrue.setErrorHandler(new IgnoreAllErrorHandler());
            docBuilderNSFalse = dbfNSFalse.newDocumentBuilder();
            docBuilderNSFalse.setErrorHandler(new IgnoreAllErrorHandler());
            initMessageDigest();
            XMLInputFactory xmlInputFactory = XMLInputFactory.newFactory();
            reader = xmlInputFactory.createXMLStreamReader(new BufferedReader(new FileReader(infile)));
            while(reader.hasNext()) {
                switch(reader.getEventType()) {
                case XMLStreamConstants.START_ELEMENT:
                    qname = reader.getName();
                    prefix = qname.getPrefix();
                    tag = qname.getLocalPart();
                    qnameS = (prefix==""?"":prefix+":") + tag;
                    if (isStartTag) {
                        if (!isXmlTagClosed)
                            parseBuf.append('&gt;');
                        isXmlTagClosed = true;
                        if (!isXmlChunkToCalcDigest) {
                            processXmlFrag(STARTTAG, lastStartTag==null?qnameS:lastStartTag, parseBuf.toString(), messageDigest, 
                                    canonicalizer, docBuilderNSTrue, docBuilderNSFalse);
                            parseBuf.setLength(0);
                        }
                    }
                    if (!isXmlChunkToCalcDigest &amp;&amp; xmlChunkToCalcDigest.contains(tag))
                            isXmlChunkToCalcDigest = true;
                    if (!isXmlTagClosed)
                        parseBuf.append('&gt;');
                    parseBuf.append('&lt;');
                    prefix = qname.getPrefix();
                    parseBuf.append(qnameS);
                    for (int i = 0; i &lt; reader.getNamespaceCount(); i++) {
                        prefix = reader.getNamespacePrefix(i);
                        parseBuf.append(" " + (prefix==null?"xmlns":"xmlns:" + prefix) + "=\"" + reader.getNamespaceURI(i) + "\"");
                    }
                    for (int i = 0; i &lt; reader.getAttributeCount(); i++) {
                        prefix = reader.getAttributePrefix(i);
                        parseBuf.append(" " + (prefix==""?"":prefix+":") + reader.getAttributeLocalName(i) + "=" + "\""  + reader.getAttributeValue(i) + "\"");
                    }
                    isXmlTagClosed = false;
                    isStartTag = true;
                    lastStartTag = qnameS;
                    break;
                case XMLStreamConstants.CHARACTERS:
                case XMLStreamConstants.COMMENT:
                    if (!isXmlTagClosed) {
                        parseBuf.append("&gt;");
                        isXmlTagClosed = true;
                    }
                    parseBuf.append(reader.getText());
                    break;
                case XMLStreamConstants.END_ELEMENT:
                    qname = reader.getName();
                    prefix = qname.getPrefix();
                    tag = qname.getLocalPart();
                    qnameS = (prefix==""?"":prefix+":") + tag;
                    isStartTag = false;
                    if (isXmlTagClosed) {
                        parseBuf.append("&lt;/");
                        parseBuf.append(qnameS);
                    } else {
                        parseBuf.append('/');
                    }
                    parseBuf.append('&gt;');
                    isXmlTagClosed = true;
                    if (isXmlChunkToCalcDigest &amp;&amp; xmlChunkToCalcDigest.contains(tag)) {
                        isXmlChunkToCalcDigest = false;
                        processXmlFrag(CHUNK, qnameS, parseBuf.toString(), messageDigest, canonicalizer, docBuilderNSTrue, docBuilderNSFalse);
                        parseBuf.setLength(0);
                    } else if (!isXmlChunkToCalcDigest) {
                        if (qnameS.equals(lastStartTag)) {
                            processXmlFrag(CHUNK, qnameS, parseBuf.toString(), messageDigest, canonicalizer, docBuilderNSTrue, docBuilderNSFalse);
                        }
                        else {
                            processXmlFrag(ENDTAG, qnameS, parseBuf.toString(), messageDigest, canonicalizer, docBuilderNSTrue, docBuilderNSFalse);
                        }
                        parseBuf.setLength(0);
                    }
                    lastStartTag = null;
                    break;
                }
                reader.next();
            }
            reader.close();
            reader = null;
            finalizeMessageDigest();
        } finally {
            if (reader != null) try{reader.close();}catch(Exception e){}
        }
        logger.debug("&lt;-- calcMsgDigestByParsingDoc()");
    }

    protected void processXmlFrag(int type, String tag, String val, MessageDigest messageDigest, Canonicalizer canonicalizer, 
            DocumentBuilder docBuilderNSTrue, DocumentBuilder docBuilderNSFalse) throws Exception {
        logger.trace("--&gt; processXmlFragOption1(). type=" + type + ", tag=" + tag + ", val=" + val);
        Document doc;
        String addedStartTag = "", addedEndTag = "", modifiedval = val;
        if (type == STARTTAG) {
            addedEndTag = "&lt;/" + tag + "&gt;";
        }
        else if (type == ENDTAG) {
            addedStartTag = "&lt;" + tag + "&gt;";
        }
        addedStartTag = "&lt;elem&gt;" + addedStartTag;
        addedEndTag = addedEndTag + "&lt;/elem&gt;";
        modifiedval = addedStartTag + val + addedEndTag;
        if (logLevel &lt;= Level.TRACE_INT) {
            logger.trace("modifiedval=" + modifiedval);
        }
        String digestval = null;
        //both useOption1OptionA = true|false should work. If one fails, try the other
        if (useStrmXmlDigestCalcOption1OptionA) {
            try {
                doc = docBuilderNSTrue.parse(new InputSource(new StringReader(modifiedval)));
                digestval = new String(canonicalizer.canonicalizeSubtree(doc));
            } catch(SAXParseException e) {
                //logger.trace("SAXParseException=" + e.getMessage());
                doc = docBuilderNSFalse.parse(new InputSource(new StringReader(modifiedval)));
                digestval = new String(canonicalizer.canonicalizeSubtree(doc));
            }
        } else {
            if (type == STARTTAG &amp;&amp; modifiedval.contains("xmlns")) {
                doc = docBuilderNSTrue.parse(new InputSource(new StringReader(modifiedval)));
            }
            else {
                doc = docBuilderNSFalse.parse(new InputSource(new StringReader(modifiedval)));
            }
            digestval = new String(canonicalizer.canonicalizeSubtree(doc));
        }
        digestval = new String(canonicalizer.canonicalizeSubtree(doc));
        digestval = digestval.replace(addedStartTag, "").replace(addedEndTag, "");
        if (logLevel &lt;= Level.TRACE_INT) {
            logger.trace("digestval=" + digestval);
        }
        messageDigest.update(digestval.getBytes());
        if (logLevel &lt;= Level.DEBUG_INT &amp;&amp; digestBuf != null) {
            digestBuf.append(digestval);
        }
        logger.trace("&lt;-- processXmlFragOption1()");
    }

    protected void calcMsgDigestNoTransformation(String xmlInputFile) throws Exception {
        logger.debug("--&gt; calcMsgDigestNoTransformation(). xmlInputFile=" + xmlInputFile);
        int len;
        String tmp;
        initMessageDigest();
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(xmlInputFile));
        boolean flag = true;
        byte[] tmpBuf = new byte[bufSize];
        while((len = bis.read(tmpBuf)) != -1) {
            tmp = new String(tmpBuf, 0, len);
            tmp = tmp.replace("\r", "");
            if (flag) {
                flag = false;
                if (tmp.startsWith("&lt;?xml")) {
                    int pos = tmp.indexOf("&gt;");
                    if (pos != -1) {
                        tmp = tmp.substring(pos+1);
                        if (tmp.startsWith("\n"))
                            tmp = tmp.substring(1);
                    }
                }
            }
            if (logLevel &lt;= Level.DEBUG_INT &amp;&amp; digestBuf != null)
                digestBuf.append(tmp);
            messageDigest.update(tmp.getBytes());
        }
        bis.close();
        finalizeMessageDigest();
        logger.debug("&lt;-- calcMsgDigestNoTransformation()");
    }

    protected Document createSignedDoc(boolean isTransformed, PrivateKey signatureKey, X509Certificate signaturePublicCert) throws Exception {
        return createSignedDoc(null, isTransformed, signatureKey, signaturePublicCert);
    }

   protected Document createSignedDoc(String xmlInputFile, boolean isTransformed, PrivateKey signatureKey, X509Certificate signaturePublicCert) throws Exception {
        logger.debug("--&gt; createSignedDoc(). xmlInputFile=" + xmlInputFile);
        BufferedInputStream bis = null;
        Document doc = null;
        try {
            String uri = "";
            Reference sigref;
            Node node;
            if (xmlInputFile != null) {
                bis = new BufferedInputStream(new FileInputStream(xmlInputFile));
                doc = docBuilder.parse(bis);
                node = doc.getDocumentElement();
            }
            else {
                doc = docBuilder.newDocument();
                node = doc.createTextNode("text");
            }
            XMLStructure content = new DOMStructure(node);
            XMLObject xmlobj = xmlSigFactory.newXMLObject
                (Collections.singletonList(content), SIGNATURE_OBJECT_ID, null, null);
            List&lt;XMLObject&gt; xmlObjs = Collections.singletonList(xmlobj);
            if (!"".equals(SIGNATURE_OBJECT_ID))
                uri = "#" + SIGNATURE_OBJECT_ID;
            if (isTransformed)
                sigref = xmlSigFactory.newReference(uri, xmlSigFactory.newDigestMethod(SIGNATURE_DIGEST_METHOD, null), 
                        Collections.singletonList(xmlSigFactory.newTransform(CANONICALIZATION_METHOD, 
                                (TransformParameterSpec) null)), null, null);
            else
                sigref = xmlSigFactory.newReference(uri, xmlSigFactory.newDigestMethod(SIGNATURE_DIGEST_METHOD, null), null, null, null);
            SignedInfo signedInfo = xmlSigFactory.newSignedInfo(
                    xmlSigFactory.newCanonicalizationMethod(CANONICALIZATION_METHOD, (C14NMethodParameterSpec) null),
                    xmlSigFactory.newSignatureMethod(SIGNATURE_METHOD, null),
                    Collections.singletonList(sigref));
            KeyInfo keyInfo = null;
            if (signaturePublicCert != null) {
                List&lt;X509Certificate&gt; list = new ArrayList&lt;X509Certificate&gt;();
                list.add(signaturePublicCert);
                X509Data kv = keyInfoFactory.newX509Data(list);
                keyInfo = keyInfoFactory.newKeyInfo(Collections.singletonList(kv));
            }
            XMLSignature signature = xmlSigFactory.newXMLSignature(signedInfo, keyInfo, xmlObjs, null, null);
            DOMSignContext dsc = new DOMSignContext(signatureKey, doc);
            signature.sign(dsc);
        } catch(Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        } finally {
            if (bis != null) try{bis.close();}catch(Exception e){}
        }
        logger.debug("&lt;-- createSignedDoc()");
        return doc;
    }

    protected boolean signXML(String xmlInputFile, String signedXmlOutputFile, boolean transformXml, PrivateKey signatureKey, X509Certificate signaturePublicCert) throws Exception {
        logger.debug("--&gt; signXML(). xmlInputFile=" + xmlInputFile + ", signedXmlOutputFile=" + signedXmlOutputFile + ", transformXml=" + transformXml);
        boolean ret = false;
        ByteArrayOutputStream baos = null;
        BufferedOutputStream bos = null;
        BufferedInputStream bis = null;
        try {
            Node node;
            Transformer trans;
            NodeList nodeList;
            logger.debug("parsing xml...." + new Date());
            calcMsgDigestByParsingDoc(xmlInputFile);
            logger.debug("parsing xml....done. " + new Date());
            Document doc = createSignedDoc(transformXml, signatureKey, signaturePublicCert);
            nodeList = doc.getElementsByTagName("DigestValue");
            if (nodeList.getLength() &gt; 0) {
                node = nodeList.item(0);
                node = node.getFirstChild();
                node.setNodeValue(digestValue);
            } else
                throw new Exception("Invalid document structure. Missing &lt;DigestValue&gt; content");
            signatureValue = null;
            nodeList = doc.getElementsByTagName("SignedInfo");
            if (nodeList.getLength() &gt; 0) {
                node = nodeList.item(0); 
                baos = new ByteArrayOutputStream();
                trans = transformerFactory.newTransformer();
                trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
                trans.transform(new DOMSource(node), new StreamResult(baos));
                baos.close();
                if (!Init.isInitialized())
                    Init.init();
                Canonicalizer canon = Canonicalizer.getInstance(CANONICALIZATION_METHOD);
                Signature signature = Signature.getInstance(SIGNATUER_ALGO);
                signature.initSign(signatureKey);
                signature.update(canon.canonicalize(baos.toByteArray()));
                byte[] signatureBuf = signature.sign();
                signatureValue = Base64.encode(signatureBuf);
                baos = null;
            } else
                throw new Exception("Invalid document structure. Missing &lt;SignedInfo&gt; content");
            nodeList = doc.getElementsByTagName("SignatureValue");
            if (nodeList.getLength() &gt; 0)
                nodeList.item(0).getFirstChild().setNodeValue(signatureValue);
            else
                throw new Exception("Invalid document structure. Missing &lt;SignatureValue&gt; content");
            String textContent = null;
            nodeList = doc.getElementsByTagName("Object");
            if (nodeList.getLength() &gt; 0) {
                node = nodeList.item(0);
                node = node.getFirstChild();
                textContent = node.getTextContent();
            } else
                throw new Exception("Invalid document structure. Missing &lt;Object&gt; content");
            baos = new ByteArrayOutputStream();
            trans = transformerFactory.newTransformer();
            trans.transform(new DOMSource(doc), new StreamResult(baos));
            baos.close();
            String tmp = baos.toString();
            baos = null;
            int pos = tmp.indexOf(textContent);
            if (pos == -1)
                throw new Exception("Invalid document structure or invalid transformation");
            String prefix = tmp.substring(0, pos);
            String suffix = tmp.substring(pos + textContent.length());
            bos = new BufferedOutputStream(new FileOutputStream(signedXmlOutputFile));
            bos.write(prefix.getBytes());
            bis = new BufferedInputStream(new FileInputStream(xmlInputFile));
            int len;
            boolean flag = true;
            byte[] tmpBuf = new byte[bufSize];
            while((len = bis.read(tmpBuf)) != -1) {
                if (flag) {
                    tmp = new String(tmpBuf, 0, len);
                    flag = false;
                    if (tmp.startsWith("&lt;?xml")) {
                        pos = tmp.indexOf("&gt;");
                        if (pos != -1) {
                            tmp = tmp.substring(pos+1);
                            if (tmp.startsWith("\r\n"))
                                tmp = tmp.substring(2);
                            if (tmp.startsWith("\n"))
                                tmp = tmp.substring(1);
                            if (tmp.startsWith("\r"))
                                tmp = tmp.substring(1);
                        }
                    }
                    bos.write(tmp.getBytes());
                } else 
                    bos.write(tmpBuf, 0, len);
            }
            bos.write(suffix.getBytes());
            ret = true;
        } catch(Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        } finally {
            if (bos != null) try{bos.close();}catch(Exception e){}
            if (bis != null) try{bis.close();}catch(Exception e){}
            if (baos != null) try{baos.close();}catch(Exception e){}
        }
        logger.debug("&lt;--signXML()");
        return ret;
    }

    protected void printNode(Node node) {
        logger.debug("--&gt; printNode() " + node.getNodeName());
        logger.debug("prefix=" + node.getPrefix() + ", baseuri=" + 
                node.getBaseURI() + ", nsuri=" + node.getNamespaceURI() + ", value=" + node.getNodeValue());
        if (node.getFirstChild() != null) {
            logger.debug("--&gt; Child of " + node.getNodeName() );
            printNode(node.getFirstChild());
            logger.debug("&lt;-- Child of " + node.getNodeName() );
        }
        if (node.getNextSibling() != null) {
            logger.debug("--&gt; Sibling of " + node.getNodeName() );
            printNode(node.getNextSibling());
            logger.debug("&lt;-- Sibling of " + node.getNodeName() );
        }
        logger.debug("&lt;-- printNode() " + node.getNodeName());
    }

    public void signDOM(String xmlInputFile, String signedXmlOutputFile, PrivateKey signatureKey, X509Certificate signaturePublicKey) throws Exception {
        logger.debug("--&gt; signDOM(). xmlInputFile=" + xmlInputFile + ", signedXmlOutputFile=" + signedXmlOutputFile);
        BufferedOutputStream bos = null;
        try {
            Document doc = createSignedDoc(xmlInputFile, true, signatureKey, signaturePublicKey);
            NodeList nodeList = doc.getElementsByTagName("DigestValue");
            if (nodeList.getLength() &gt; 0)
                digestValue = nodeList.item(0).getFirstChild().getNodeValue();
            nodeList = doc.getElementsByTagName("SignatureValue");
            if (nodeList.getLength() &gt; 0)
                signatureValue = nodeList.item(0).getFirstChild().getNodeValue();
            bos = new BufferedOutputStream(new FileOutputStream(signedXmlOutputFile));
            Transformer transformer = transformerFactory.newTransformer();
            transformer.transform(new DOMSource(doc), new StreamResult(bos));
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        } finally {
            if (bos != null) try{bos.close();}catch(Exception e) {}
        }
        logger.debug("&lt;-- signDOM()");
    }

    public boolean signStreaming(String xmlInputFile, String signedXmlOutputFile, PrivateKey signatureKey, X509Certificate signaturePublicCert) throws Exception {
        logger.debug("--&gt; signStreaming(). xmlInputFile=" + xmlInputFile + ", signedXmlOutputFile=" + signedXmlOutputFile);
        boolean flag = signXML(xmlInputFile, signedXmlOutputFile, false, signatureKey, signaturePublicCert);
        logger.debug("&lt;-- signStreaming()");
        return flag;
    }

    public boolean signStreamingWithCanonicalization(String xmlInputFile, String signedXmlOutputFile, PrivateKey signatureKey, X509Certificate signaturePublicCert) throws Exception {
        logger.debug("--&gt; signStreamingWithCanonicalization(). xmlInputFile=" + xmlInputFile + ", signedXmlOutputFile=" + signedXmlOutputFile);
        boolean flag = signXML(xmlInputFile, signedXmlOutputFile, true, signatureKey, signaturePublicCert);
        logger.debug("&lt;-- signStreamingWithCanonicalization()");
        return flag;
    }
}

</code></pre>

<ol>
<li>Add code for TestMain.java</li>
</ol>

<pre><code>package fatca;

import java.security.PrivateKey;
import java.security.cert.X509Certificate;

import org.apache.log4j.Logger;

public class TestMain {
    protected static Logger logger = Logger.getLogger(new Object(){}.getClass().getEnclosingClass().getName());



    private FATCAXmlSigner signer = null;
    private FATCAPackager pkger = null;

    // sender FFI or HCTA
    private String canadaGiin = "000000.00000.TA.124";
    private PrivateKey canadaSigKey = null;
    private X509Certificate canadaPubCert = null;

    // receiver
    private String usaGiin = "000000.00000.TA.840";
    private X509Certificate usaCert = null;
    private PrivateKey usaPrivateKey = null; 

    // approver - for model1 option2
    private String mexicoGiin = "000000.00000.TA.484";
    private X509Certificate mexicoPubCert = null;
    private PrivateKey mexicoPrivateKey = null; 

    public TestMain() throws Exception{
        signer = new FATCAXmlSigner();
        pkger = new FATCAPackager();
        canadaSigKey = UtilShared.getPrivateKey("jks", "Keystore/Canada_PrepTool/KSprivateCA.jks", "pwd123", "CAN2014", "CANADAcert");
        canadaPubCert = UtilShared.getCert("jks", "Keystore/Canada_PrepTool/KSpublicCA.jks", "pwd123", "CANADAcert");
        usaCert = UtilShared.getCert("jks", "Keystore/IRS_PrepTool/KSpublicUS.jks", "pwd123", "IRScert");
        mexicoPubCert = UtilShared.getCert("jks", "Keystore/Mexico_PrepTool/KSpublicMX.jks", "pwd123", "MEXICOcert");
        usaPrivateKey = UtilShared.getPrivateKey("jks", "Keystore/IRS_PrepTool/KSprivateUS.jks", "pwd123", "password", "IRScert");
        mexicoPrivateKey = UtilShared.getPrivateKey("jks", "Keystore/Mexico_PrepTool/KSprivateMX.jks", "pwd123", "MEX2014", "MEXICOcert");
    }

    public static void main(String[] args) throws Exception {
        String canadaXml = "000000.00000.TA.124_0_Payload.xml";
        String signedCanadaXml = canadaXml + ".signed";

        FATCAPackager.isCanonicalization = false;

        TestMain m = new TestMain();

        m.signer.signStreaming(canadaXml, signedCanadaXml, m.canadaSigKey, m.canadaPubCert);
        m.signer.signDOM(canadaXml, signedCanadaXml, m.canadaSigKey, m.canadaPubCert);

        String idesOutFile = m.pkger.createPkg(signedCanadaXml, m.canadaGiin, m.usaGiin, m.usaCert, 2014);
        logger.debug(idesOutFile);

        m.pkger.unpack(idesOutFile, m.usaPrivateKey);

        idesOutFile = m.pkger.createPkgWithApprover(signedCanadaXml, m.canadaGiin, m.usaGiin, m.usaCert, m.mexicoGiin, m.mexicoPubCert, 2014);
        logger.debug(idesOutFile);

        m.pkger.unpackForApprover(idesOutFile, m.mexicoPrivateKey);

        idesOutFile = m.pkger.signAndCreatePkg(canadaXml, m.canadaSigKey, m.canadaPubCert, m.canadaGiin, m.usaGiin, m.usaCert, 2014);
        logger.debug(idesOutFile);

        m.pkger.unpack(idesOutFile, m.usaPrivateKey);

        idesOutFile = m.pkger.signAndCreatePkgWithApprover(canadaXml, m.canadaSigKey, m.canadaPubCert, m.canadaGiin, m.usaGiin, m.usaCert, m.mexicoGiin, m.mexicoPubCert, 2014);
        logger.debug(idesOutFile);

        m.pkger.unpackForApprover(idesOutFile, m.mexicoPrivateKey);
    }
}

</code></pre>

<ol>
<li>Add code for UtilShared.java</li>
</ol>

<pre><code>package fatca;

import java.io.File;
import java.io.FileInputStream;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.UUID;

import javax.xml.crypto.dsig.Reference;
import javax.xml.crypto.dsig.Transform;
import javax.xml.crypto.dsig.XMLSignature;
import javax.xml.crypto.dsig.XMLSignatureFactory;
import javax.xml.crypto.dsig.XMLSignature.SignatureValue;
import javax.xml.crypto.dsig.dom.DOMValidateContext;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.apache.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.sun.org.apache.xml.internal.security.utils.Base64;

public class UtilShared {
    protected static Logger logger = Logger.getLogger(new Object(){}.getClass().getEnclosingClass().getName());

    public static String AES_TRANSFORMATION = "AES/ECB/PKCS5Padding";
    public static String RSA_TRANSFORMATION = "RSA";

    public static String SECRET_KEY_ALGO = "AES";
    public static int SECRET_KEY_SIZE = 256;

    public static String KEYSTORE_TYPE = "pkcs12";
    public static String CERTIFICATE_TYPE = "X.509";

    public static String genRandomId() {
        UUID uuid = UUID.randomUUID();
        return uuid + "@" + System.identityHashCode(uuid);
    }
    public static X509Certificate getCert(String keystorefile, String keystorepwd) throws Exception {
        return getCert(KEYSTORE_TYPE, keystorefile, keystorepwd, null);
    }

    public static X509Certificate getCert(String keystorefile, String keystorepwd, String alias) throws Exception {
        return getCert(KEYSTORE_TYPE, keystorefile, keystorepwd, alias);
    }

    public static X509Certificate getCert(String keystoretype, String keystorefile, String keystorepwd, String alias) throws Exception {
        try {
            //KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
            KeyStore keystore = KeyStore.getInstance(keystoretype);
            FileInputStream fis = new FileInputStream(keystorefile);
            keystore.load(fis, keystorepwd.toCharArray());
            fis.close();
            if (alias == null) {
                Enumeration&lt;String&gt; e = keystore.aliases();
                if (e.hasMoreElements())
                    alias = e.nextElement();
            }
            if (alias != null) {
                X509Certificate cert = (X509Certificate)keystore.getCertificate(alias);
                return cert;
            }
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        }
        return null;
    }
    public static PrivateKey getPrivateKey(String keystorefile, String keystorepwd, String keypwd, String alias) throws Exception {
        return getPrivateKey(KEYSTORE_TYPE, keystorefile, keystorepwd, keypwd, alias);
    }

    public static PrivateKey getPrivateKey(String keystorefile, String keystorepwd, String keypwd) throws Exception {
        return getPrivateKey(KEYSTORE_TYPE, keystorefile, keystorepwd, keypwd, null);
    }

    public static PrivateKey getPrivateKey(String keystoretype, String keystorefile, String keystorepwd, String keypwd, String alias) throws Exception {
        try {
            //KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
            KeyStore keystore = KeyStore.getInstance(keystoretype);
            FileInputStream fis = new FileInputStream(keystorefile);
            keystore.load(fis, keystorepwd.toCharArray());
            fis.close();
            if (alias == null) {
                Enumeration&lt;String&gt; e = keystore.aliases();
                if (e.hasMoreElements())
                    alias = e.nextElement();
            }
            if (alias != null) {
                PrivateKey privkey = (PrivateKey)keystore.getKey(alias, keypwd.toCharArray());
                if (privkey == null)
                    privkey = (PrivateKey)keystore.getKey(alias.toLowerCase(), keypwd.toCharArray());
                return privkey;
            }
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        }
        return null;
    }

    public static boolean verifySignatureDOM(String signedPlainTextFile, PublicKey sigkey) throws Exception  {
        logger.debug("--&gt; verifySignatureDOM()");
        boolean ret = false;
        XMLSignatureFactory xmlsigfac;
        XMLSignature signature;
        NodeList nl;
        DocumentBuilderFactory dbf;
        Document doc;
        DOMValidateContext valContext;
        boolean coreValidity, sv, refValid;
        Iterator&lt;?&gt; iter;
        try {
            xmlsigfac = XMLSignatureFactory.getInstance();

            dbf = DocumentBuilderFactory.newInstance();
            dbf.setNamespaceAware(true);
            DocumentBuilder db = dbf.newDocumentBuilder();

            doc = db.parse(new File(signedPlainTextFile));
            nl = doc.getElementsByTagNameNS(XMLSignature.XMLNS, "Object");
            if (nl.getLength() == 0)
                throw new Exception("Cannot find Object element");
            Node objNode = nl.item(0);

            String id = "";
            Node attrId = objNode.getAttributes().getNamedItem("Id");
            if (attrId  != null)
                id = attrId.getTextContent();
            Element fakeObjNode = doc.createElementNS(XMLSignature.XMLNS, "Object");
            fakeObjNode.setAttribute("Id", id);
            doc.getDocumentElement().replaceChild(fakeObjNode, objNode);
            nl = doc.getElementsByTagNameNS(XMLSignature.XMLNS, "Signature");
            if (nl.getLength() == 0) {
                throw new Exception("Cannot find Signature element");
            }
            Node sigNode = nl.item(0);

            valContext = new DOMValidateContext(sigkey, sigNode);

            //very important
            doc.getDocumentElement().replaceChild(objNode, fakeObjNode);
            signature = xmlsigfac.unmarshalXMLSignature(valContext);
            coreValidity = signature.validate(valContext);

            logger.debug("Signature core validation " + coreValidity);
            //if (coreValidity == false) {
                SignatureValue sigval = signature.getSignatureValue();
                sv = sigval.validate(valContext);
                logger.debug("SignatureValue validation status: " + sv);
                //if (sv == false) {
                    // Check the validation status of each Reference.
                    iter = signature.getSignedInfo().getReferences().iterator();
                    Reference ref;
                    for (int j=0; iter.hasNext(); j++) {
                        ref = (Reference) iter.next();
                        refValid = ref.validate(valContext);
                        logger.debug("ref["+j+"] validity status: " + refValid);
                        logger.debug("ref.getURI()=" + ref.getURI());
                        logger.debug("ref.getCalculatedDigestValue()=" + Base64.encode(ref.getCalculatedDigestValue()));
                        logger.debug("ref.getDigestValue()=" + Base64.encode(ref.getDigestValue()));
                        List&lt;?&gt; lt = ref.getTransforms();
                        Transform tr;
                        for (int i = 0; i &lt; lt.size(); i++) {
                            tr = (Transform)lt.get(i);
                            logger.debug("transform.getAlgorithm()=" + tr.getAlgorithm());
                        }
                    }
                //}
            //}
            ret = coreValidity;
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        } finally {
        }
        logger.debug("&lt;-- verifySignatureDOM()");
        return ret;
    }
}

</code></pre>

<h2>
<a id="test-payload-file" class="anchor" href="#test-payload-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>Test Payload file</h2>

<p>Place the test Payload file from the repository .zip file into the root of the IDESDataPreparation folder. This is the FATCA Payload file that will be signed, encrypted, and packaged for transmission through IDES.</p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image10.png" alt="Image 10"><br>
Figure 10  </p>

<h2>
<a id="log4jxml-file" class="anchor" href="#log4jxml-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>log4j.xml file</h2>

<p>Place the log4j.xml file from the repository .zip file into the root of the IDESDataPreparation/bin folder. This is the settings file for the console logging .jar.</p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image11.png" alt="Image 11"><br>
Figure 11  </p>

<h2>
<a id="project-contents" class="anchor" href="#project-contents" aria-hidden="true"><span class="octicon octicon-link"></span></a>Project Contents</h2>

<p>Refreshing the contents of the project will show the newly added folders and files:
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image12.png" alt="Image 12"><br>
Figure 12  </p>

<h2>
<a id="project-properties" class="anchor" href="#project-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Project Properties</h2>

<p>Enter the Project Properties screen and enter the Java Build Path selection:
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image13.png" alt="Image 13"><br>
Figure 13  </p>

<p>Add the <strong>generated</strong> folder to the <strong>Source</strong> tab and click OK
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image14.png" alt="Image 14"><br>
Figure 14  </p>

<p>Updated <strong>Source</strong> tab
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image15.png" alt="Image 15"><br>
Figure 15  </p>

<p>Select the <strong>Libraries</strong> tab
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image16.png" alt="Image 16"><br>
Figure 16  </p>

<p>Select the <strong>Add JARs</strong> button and browse to the log4j-1.2.16.jar file in the lib folder and click the OK button to add:
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image17.png" alt="Image 17"><br>
Figure 17</p>

<p>Updated <strong>Libraries</strong> tab
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image18.png" alt="Image 18"><br>
Figure 18  </p>

<p><strong>Running The Application</strong>
Highlight the TestMain.java file located in the src\fatca folder and start the application. The Console tab will display the logging information from the program.</p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image19.png" alt="Image 19"><br>
Figure 19 </p>

<p>The output files will be placed in the root of the IDESDataPreparation folder:
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image20.png" alt="Image 20"><br>
Figure 20 </p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">IDES Data Preparation - Java maintained by <a href="https://github.com/IRSgov">IRSgov</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
