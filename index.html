<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="IDES Data Preparation - Java : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>IDES Data Preparation - Java</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/IRSgov/IDES-Data-Preparation-Java">View on GitHub</a>

          <h1 id="project_title">IDES Data Preparation - Java</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/IRSgov/IDES-Data-Preparation-Java/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/IRSgov/IDES-Data-Preparation-Java/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>
<a id="ides-data-preparation" class="anchor" href="#ides-data-preparation" aria-hidden="true"><span class="octicon octicon-link"></span></a>IDES Data Preparation</h2>

<p>The International Data Exchange Service (IDES) is a secure managed file transfer service that allows financial institutions and tax authorities to securely send information on financial accounts held by U.S. taxpayers in accordance with the Foreign Account Tax Compliance Act (FATCA). Files transmitted via IDES must be encrypted and packaged in accordance with published data preparation instructions.  The data preparation process is an important step to ensure that information transmitted via IDES conforms to U.S security standards to safeguard sensitive information.</p>

<p>The IDES Data Preparation Java project repository demonstrates a sample working application built using Java inside of <a href="http://www.eclipse.org/">Eclipse</a>.  An application was also developed using .Net, see <a href="http://irsgov.github.io/IDES-Data-Preparation-Dot-Net">IDES Data Preparation .Net</a> for more information.</p>

<p>The example explains how to use the code to develop an application that will create an IDES data packet and decrypt notifications. The project starts with a validated FATCA XML file. The application does not validate the XML or metadata schemas. The sample application will digitally sign, encrypt, compress, and archive the data packet into a compliant .ZIP format.  </p>

<p>Please note that there are many open market tools that produce the same results; however, the IRS does not endorse any commercial products, including the frameworks used in the example.  </p>

<h3>
<a id="application-setup" class="anchor" href="#application-setup" aria-hidden="true"><span class="octicon octicon-link"></span></a>Application Setup</h3>

<p>The sample application was created using Eclipse 4.4.1 and JRE version 1.8.0_40. </p>

<p>This repository includes a .zip file that contains several files necessary to this sample application. While some files can be copied and pasted from this guide, some must be downloaded from the .zip file and placed as indicated by the guide.</p>

<p>Keystore - This folder contains a set of .jks files containing self-signed test public and private keys used by the application.</p>

<p>lib - This folder contains the log4j-1.2.16.jar file which provides the console logging for the application.</p>

<p>generated - This folder has a set of .java files related to the metadata used by the application.</p>

<p>src - This folder has the main set of .java files, including testmain.java which is used to start the application.</p>

<p>000000.00000.TA.124_0_Payload.xml - This is the FATCA XML that will be signed, encrypted, and packaged by the application. This is a test file for the application and is not intended to portray a specific business case.</p>

<h3>
<a id="create-a-new-project" class="anchor" href="#create-a-new-project" aria-hidden="true"><span class="octicon octicon-link"></span></a>Create a New Project</h3>

<p>Open <strong>Eclipse</strong>, select <strong>New</strong>, select <strong>Java Project</strong>. </p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image1.png" alt="Image 1"><br>
Figure 1   </p>

<p>Enter <strong>IDESDataPreparation</strong> for the Project Name and select the JRE that you will use. The sample is using jre1.8.0_40. Click the <strong>Next</strong> button.</p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image2.png" alt="Image 2"><br>
Figure 2     </p>

<p>Click <strong>Finish</strong>, these will be set up later</p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image3.png" alt="Image 3"><br>
Figure 3</p>

<p>The Eclipse project with the default settings:
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image4.png" alt="Image 4"><br>
Figure 4</p>

<p>The file system for the new project:
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image5.png" alt="Image 5"><br>
Figure 5</p>

<h2>
<a id="generated-folder" class="anchor" href="#generated-folder" aria-hidden="true"><span class="octicon octicon-link"></span></a>generated folder</h2>

<p>Add the generated folder from the .zip repository or replicate the folder structure below. 
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image6.png" alt="Image 6"><br>
Figure 6</p>

<ol>
<li>Add code for FATCAEntCommunicationTypeCdType.java</li>
</ol>

<pre><code>//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 
// See &lt;a href="http://java.sun.com/xml/jaxb"&gt;http://java.sun.com/xml/jaxb&lt;/a&gt; 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2014.11.05 at 11:20:51 AM EST 
//


package fatca.idessenderfilemetadata;

import javax.xml.bind.annotation.XmlEnum;
import javax.xml.bind.annotation.XmlType;


/**
 * &lt;p&gt;Java class for FATCAEntCommunicationTypeCdType.
 * 
 * &lt;p&gt;The following schema fragment specifies the expected content contained within this class.
 * &lt;p&gt;
 * &lt;pre&gt;
 * &amp;lt;simpleType name="FATCAEntCommunicationTypeCdType"&gt;
 *   &amp;lt;restriction base="{http://www.w3.org/2001/XMLSchema}string"&gt;
 *     &amp;lt;enumeration value="NTF"/&gt;
 *     &amp;lt;enumeration value="RPT"/&gt;
 *   &amp;lt;/restriction&gt;
 * &amp;lt;/simpleType&gt;
 * &lt;/pre&gt;
 * 
 */
@XmlType(name = "FATCAEntCommunicationTypeCdType")
@XmlEnum
public enum FATCAEntCommunicationTypeCdType {


    /**
     * FATCA_NOTIFICATION - FATCA Notification communication
     * 
     */
    NTF,

    /**
     * FATCA_REPORT - FATCA Report communication
     * 
     */
    RPT;

    public String value() {
        return name();
    }

    public static FATCAEntCommunicationTypeCdType fromValue(String v) {
        return valueOf(v);
    }

}

</code></pre>

<ol>
<li>Add code for FATCAIDESSenderFileMetadataType.java</li>
</ol>

<pre><code>//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 
// See &lt;a href="http://java.sun.com/xml/jaxb"&gt;http://java.sun.com/xml/jaxb&lt;/a&gt; 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2014.11.05 at 11:20:51 AM EST 
//


package fatca.idessenderfilemetadata;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.datatype.XMLGregorianCalendar;


/**
 * 
 *              
 * &lt;pre&gt;
 * &amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;&amp;lt;Component xmlns="urn:fatca:idessenderfilemetadata" xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&amp;gt;&amp;lt;DictionaryEntryNm&amp;gt;FATCA IDES Sender File Metadata Type&amp;lt;/DictionaryEntryNm&amp;gt;&amp;lt;MajorVersionNum&amp;gt;1&amp;lt;/MajorVersionNum&amp;gt;&amp;lt;MinorVersionNum&amp;gt;0&amp;lt;/MinorVersionNum&amp;gt;&amp;lt;VersionEffectiveBeginDt&amp;gt;2014-08-29&amp;lt;/VersionEffectiveBeginDt&amp;gt;&amp;lt;VersionDescriptionTxt&amp;gt;Initial Version&amp;lt;/VersionDescriptionTxt&amp;gt;&amp;lt;Description&amp;gt;Type for a group that defines the information contained in the FATCA IDES Sender File Metadata&amp;lt;/Description&amp;gt;
 *              &amp;lt;/Component&amp;gt;
 * &lt;/pre&gt;
 * 
 *          
 * 
 * &lt;p&gt;Java class for FATCAIDESSenderFileMetadataType complex type.
 * 
 * &lt;p&gt;The following schema fragment specifies the expected content contained within this class.
 * 
 * &lt;pre&gt;
 * &amp;lt;complexType name="FATCAIDESSenderFileMetadataType"&gt;
 *   &amp;lt;complexContent&gt;
 *     &amp;lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &amp;lt;sequence&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}FATCAEntitySenderId"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}FATCAEntityReceiverId"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}FATCAEntCommunicationTypeCd"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}SenderFileId"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}FileCreateTs"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}TaxYear"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}FileRevisionInd"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}OriginalIDESTransmissionId" minOccurs="0"/&gt;
 *         &amp;lt;element ref="{urn:fatca:idessenderfilemetadata}SenderContactEmailAddressTxt" minOccurs="0"/&gt;
 *       &amp;lt;/sequence&gt;
 *     &amp;lt;/restriction&gt;
 *   &amp;lt;/complexContent&gt;
 * &amp;lt;/complexType&gt;
 * &lt;/pre&gt;
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "FATCAIDESSenderFileMetadataType", propOrder = {
    "fatcaEntitySenderId",
    "fatcaEntityReceiverId",
    "fatcaEntCommunicationTypeCd",
    "senderFileId",
    "fileCreateTs",
    "taxYear",
    "fileRevisionInd",
    "originalIDESTransmissionId",
    "senderContactEmailAddressTxt"
})
public class FATCAIDESSenderFileMetadataType {

    @XmlElement(name = "FATCAEntitySenderId", required = true)
    protected String fatcaEntitySenderId;
    @XmlElement(name = "FATCAEntityReceiverId", required = true)
    protected String fatcaEntityReceiverId;
    @XmlElement(name = "FATCAEntCommunicationTypeCd", required = true)
    protected FATCAEntCommunicationTypeCdType fatcaEntCommunicationTypeCd;
    @XmlElement(name = "SenderFileId", required = true)
    protected String senderFileId;
    @XmlElement(name = "FileCreateTs", required = true)
    protected String fileCreateTs;
    @XmlElement(name = "TaxYear", required = true)
    protected XMLGregorianCalendar taxYear;
    @XmlElement(name = "FileRevisionInd")
    protected boolean fileRevisionInd;
    @XmlElement(name = "OriginalIDESTransmissionId")
    protected String originalIDESTransmissionId;
    @XmlElement(name = "SenderContactEmailAddressTxt")
    protected String senderContactEmailAddressTxt;

    /**
     * Gets the value of the fatcaEntitySenderId property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getFATCAEntitySenderId() {
        return fatcaEntitySenderId;
    }

    /**
     * Sets the value of the fatcaEntitySenderId property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setFATCAEntitySenderId(String value) {
        this.fatcaEntitySenderId = value;
    }

    /**
     * Gets the value of the fatcaEntityReceiverId property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getFATCAEntityReceiverId() {
        return fatcaEntityReceiverId;
    }

    /**
     * Sets the value of the fatcaEntityReceiverId property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setFATCAEntityReceiverId(String value) {
        this.fatcaEntityReceiverId = value;
    }

    /**
     * Gets the value of the fatcaEntCommunicationTypeCd property.
     * 
     * @return
     *     possible object is
     *     {@link FATCAEntCommunicationTypeCdType }
     *     
     */
    public FATCAEntCommunicationTypeCdType getFATCAEntCommunicationTypeCd() {
        return fatcaEntCommunicationTypeCd;
    }

    /**
     * Sets the value of the fatcaEntCommunicationTypeCd property.
     * 
     * @param value
     *     allowed object is
     *     {@link FATCAEntCommunicationTypeCdType }
     *     
     */
    public void setFATCAEntCommunicationTypeCd(FATCAEntCommunicationTypeCdType value) {
        this.fatcaEntCommunicationTypeCd = value;
    }

    /**
     * Gets the value of the senderFileId property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getSenderFileId() {
        return senderFileId;
    }

    /**
     * Sets the value of the senderFileId property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setSenderFileId(String value) {
        this.senderFileId = value;
    }

    /**
     * Gets the value of the fileCreateTs property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getFileCreateTs() {
        return fileCreateTs;
    }

    /**
     * Sets the value of the fileCreateTs property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setFileCreateTs(String value) {
        this.fileCreateTs = value;
    }

    /**
     * Gets the value of the taxYear property.
     * 
     * @return
     *     possible object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public XMLGregorianCalendar getTaxYear() {
        return taxYear;
    }

    /**
     * Sets the value of the taxYear property.
     * 
     * @param value
     *     allowed object is
     *     {@link XMLGregorianCalendar }
     *     
     */
    public void setTaxYear(XMLGregorianCalendar value) {
        this.taxYear = value;
    }

    /**
     * Gets the value of the fileRevisionInd property.
     * 
     */
    public boolean isFileRevisionInd() {
        return fileRevisionInd;
    }

    /**
     * Sets the value of the fileRevisionInd property.
     * 
     */
    public void setFileRevisionInd(boolean value) {
        this.fileRevisionInd = value;
    }

    /**
     * Gets the value of the originalIDESTransmissionId property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getOriginalIDESTransmissionId() {
        return originalIDESTransmissionId;
    }

    /**
     * Sets the value of the originalIDESTransmissionId property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setOriginalIDESTransmissionId(String value) {
        this.originalIDESTransmissionId = value;
    }

    /**
     * Gets the value of the senderContactEmailAddressTxt property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getSenderContactEmailAddressTxt() {
        return senderContactEmailAddressTxt;
    }

    /**
     * Sets the value of the senderContactEmailAddressTxt property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setSenderContactEmailAddressTxt(String value) {
        this.senderContactEmailAddressTxt = value;
    }

}

3. Add code for ObjectFactory.java
</code></pre>

<p>//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 
// See <a href="http://java.sun.com/xml/jaxb"></a><a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2014.11.05 at 11:20:51 AM EST 
//</p>

<p>package fatca.idessenderfilemetadata;</p>

<p>import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlElementDecl;
import javax.xml.bind.annotation.XmlRegistry;
import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.namespace.QName;</p>

<p>/**</p>

<ul>
<li>This object contains factory methods for each </li>
<li>Java content interface and Java element interface </li>
<li>generated in the fatca.idessenderfilemetadata package. </li>
<li><p>An ObjectFactory allows you to programatically </p></li>
<li>construct new instances of the Java representation </li>
<li>for XML content. The Java representation of XML </li>
<li>content can consist of schema derived interfaces </li>
<li>and classes representing the binding of schema </li>
<li>type definitions, element declarations and model </li>
<li>groups.  Factory methods for each of these are </li>
<li>provided in this class.</li>
<li>
<p>*/
@XmlRegistry
public class ObjectFactory {</p>

<p>private final static QName _SenderFileId_QNAME = new QName("urn:fatca:idessenderfilemetadata", "SenderFileId");
private final static QName _FATCAEntCommunicationTypeCd_QNAME = new QName("urn:fatca:idessenderfilemetadata", "FATCAEntCommunicationTypeCd");
private final static QName _TaxYear_QNAME = new QName("urn:fatca:idessenderfilemetadata", "TaxYear");
private final static QName _FileRevisionInd_QNAME = new QName("urn:fatca:idessenderfilemetadata", "FileRevisionInd");
private final static QName _FATCAIDESSenderFileMetadata_QNAME = new QName("urn:fatca:idessenderfilemetadata", "FATCAIDESSenderFileMetadata");
private final static QName _SenderContactEmailAddressTxt_QNAME = new QName("urn:fatca:idessenderfilemetadata", "SenderContactEmailAddressTxt");
private final static QName _FATCAEntitySenderId_QNAME = new QName("urn:fatca:idessenderfilemetadata", "FATCAEntitySenderId");
private final static QName _FATCAEntityReceiverId_QNAME = new QName("urn:fatca:idessenderfilemetadata", "FATCAEntityReceiverId");
private final static QName _OriginalIDESTransmissionId_QNAME = new QName("urn:fatca:idessenderfilemetadata", "OriginalIDESTransmissionId");
private final static QName _FileCreateTs_QNAME = new QName("urn:fatca:idessenderfilemetadata", "FileCreateTs");</p>

<p>/**</p>

<ul>
<li>Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fatca.idessenderfilemetadata</li>
<li>
*/
public ObjectFactory() {
}</li>
</ul>

<p>/**</p>

<ul>
<li>Create an instance of {<a href="https://github.com/link" class="user-mention">@link</a> FATCAIDESSenderFileMetadataType }</li>
<li>
*/
public FATCAIDESSenderFileMetadataType createFATCAIDESSenderFileMetadataType() {
return new FATCAIDESSenderFileMetadataType();
}</li>
</ul>

<p>/**</p>

<ul>
<li>Create an instance of {<a href="https://github.com/link" class="user-mention">@link</a> JAXBElement }{<a href="https://github.com/code" class="user-mention">@code</a> &lt;}{<a href="https://github.com/link" class="user-mention">@link</a> String }{<a href="https://github.com/code" class="user-mention">@code</a> &gt;}}</li>
<li>
*/
@XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "SenderFileId")
public JAXBElement createSenderFileId(String value) {
return new JAXBElement(_SenderFileId_QNAME, String.class, null, value);
}</li>
</ul>

<p>/**</p>

<ul>
<li>Create an instance of {<a href="https://github.com/link" class="user-mention">@link</a> JAXBElement }{<a href="https://github.com/code" class="user-mention">@code</a> &lt;}{<a href="https://github.com/link" class="user-mention">@link</a> FATCAEntCommunicationTypeCdType }{<a href="https://github.com/code" class="user-mention">@code</a> &gt;}}</li>
<li>
*/
@XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "FATCAEntCommunicationTypeCd")
public JAXBElement createFATCAEntCommunicationTypeCd(FATCAEntCommunicationTypeCdType value) {
return new JAXBElement(_FATCAEntCommunicationTypeCd_QNAME, FATCAEntCommunicationTypeCdType.class, null, value);
}</li>
</ul>

<p>/**</p>

<ul>
<li>Create an instance of {<a href="https://github.com/link" class="user-mention">@link</a> JAXBElement }{<a href="https://github.com/code" class="user-mention">@code</a> &lt;}{<a href="https://github.com/link" class="user-mention">@link</a> XMLGregorianCalendar }{<a href="https://github.com/code" class="user-mention">@code</a> &gt;}}</li>
<li>
*/
@XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "TaxYear")
public JAXBElement createTaxYear(XMLGregorianCalendar value) {
return new JAXBElement(_TaxYear_QNAME, XMLGregorianCalendar.class, null, value);
}</li>
</ul>

<p>/**</p>

<ul>
<li>Create an instance of {<a href="https://github.com/link" class="user-mention">@link</a> JAXBElement }{<a href="https://github.com/code" class="user-mention">@code</a> &lt;}{<a href="https://github.com/link" class="user-mention">@link</a> Boolean }{<a href="https://github.com/code" class="user-mention">@code</a> &gt;}}</li>
<li>
*/
@XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "FileRevisionInd")
public JAXBElement createFileRevisionInd(Boolean value) {
return new JAXBElement(_FileRevisionInd_QNAME, Boolean.class, null, value);
}</li>
</ul>

<p>/**</p>

<ul>
<li>Create an instance of {<a href="https://github.com/link" class="user-mention">@link</a> JAXBElement }{<a href="https://github.com/code" class="user-mention">@code</a> &lt;}{<a href="https://github.com/link" class="user-mention">@link</a> FATCAIDESSenderFileMetadataType }{<a href="https://github.com/code" class="user-mention">@code</a> &gt;}}</li>
<li>
*/
@XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "FATCAIDESSenderFileMetadata")
public JAXBElement createFATCAIDESSenderFileMetadata(FATCAIDESSenderFileMetadataType value) {
return new JAXBElement(_FATCAIDESSenderFileMetadata_QNAME, FATCAIDESSenderFileMetadataType.class, null, value);
}</li>
</ul>

<p>/**</p>

<ul>
<li>Create an instance of {<a href="https://github.com/link" class="user-mention">@link</a> JAXBElement }{<a href="https://github.com/code" class="user-mention">@code</a> &lt;}{<a href="https://github.com/link" class="user-mention">@link</a> String }{<a href="https://github.com/code" class="user-mention">@code</a> &gt;}}</li>
<li>
*/
@XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "SenderContactEmailAddressTxt")
public JAXBElement createSenderContactEmailAddressTxt(String value) {
return new JAXBElement(_SenderContactEmailAddressTxt_QNAME, String.class, null, value);
}</li>
</ul>

<p>/**</p>

<ul>
<li>Create an instance of {<a href="https://github.com/link" class="user-mention">@link</a> JAXBElement }{<a href="https://github.com/code" class="user-mention">@code</a> &lt;}{<a href="https://github.com/link" class="user-mention">@link</a> String }{<a href="https://github.com/code" class="user-mention">@code</a> &gt;}}</li>
<li>
*/
@XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "FATCAEntitySenderId")
public JAXBElement createFATCAEntitySenderId(String value) {
return new JAXBElement(_FATCAEntitySenderId_QNAME, String.class, null, value);
}</li>
</ul>

<p>/**</p>

<ul>
<li>Create an instance of {<a href="https://github.com/link" class="user-mention">@link</a> JAXBElement }{<a href="https://github.com/code" class="user-mention">@code</a> &lt;}{<a href="https://github.com/link" class="user-mention">@link</a> String }{<a href="https://github.com/code" class="user-mention">@code</a> &gt;}}</li>
<li>
*/
@XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "FATCAEntityReceiverId")
public JAXBElement createFATCAEntityReceiverId(String value) {
return new JAXBElement(_FATCAEntityReceiverId_QNAME, String.class, null, value);
}</li>
</ul>

<p>/**</p>

<ul>
<li>Create an instance of {<a href="https://github.com/link" class="user-mention">@link</a> JAXBElement }{<a href="https://github.com/code" class="user-mention">@code</a> &lt;}{<a href="https://github.com/link" class="user-mention">@link</a> String }{<a href="https://github.com/code" class="user-mention">@code</a> &gt;}}</li>
<li>
*/
@XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "OriginalIDESTransmissionId")
public JAXBElement createOriginalIDESTransmissionId(String value) {
return new JAXBElement(_OriginalIDESTransmissionId_QNAME, String.class, null, value);
}</li>
</ul>

<p>/**</p>

<ul>
<li>Create an instance of {<a href="https://github.com/link" class="user-mention">@link</a> JAXBElement }{<a href="https://github.com/code" class="user-mention">@code</a> &lt;}{<a href="https://github.com/link" class="user-mention">@link</a> String }{<a href="https://github.com/code" class="user-mention">@code</a> &gt;}}</li>
<li>
*/
@XmlElementDecl(namespace = "urn:fatca:idessenderfilemetadata", name = "FileCreateTs")
public JAXBElement createFileCreateTs(String value) {
return new JAXBElement(_FileCreateTs_QNAME, String.class, null, value);
}</li>
</ul>
</li>
</ul>

<p>}</p>

<ol>
<li>Add code for package-info.java</li>
</ol>

<pre><code>//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 
// See &lt;a href="http://java.sun.com/xml/jaxb"&gt;http://java.sun.com/xml/jaxb&lt;/a&gt; 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2014.11.05 at 11:20:51 AM EST 
//

@javax.xml.bind.annotation.XmlSchema(namespace = "urn:fatca:idessenderfilemetadata", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package fatca.idessenderfilemetadata;

</code></pre>

<h2>
<a id="keystore" class="anchor" href="#keystore" aria-hidden="true"><span class="octicon octicon-link"></span></a>Keystore</h2>

<p>Place the Keystore folder from the repository .zip file into the IDESDataPreparation folder. This will contain the test keys that the program will use. </p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image7.png" alt="Image 7"><br>
Figure 7  </p>

<h2>
<a id="lib-folder" class="anchor" href="#lib-folder" aria-hidden="true"><span class="octicon octicon-link"></span></a>lib folder</h2>

<p>Place the lib folder from the repository .zip file into the IDESDataPreparation folder. This will contain the .jar file for the console logging functionality.</p>

<p><img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image8.png" alt="Image 8"><br>
Figure 8  </p>

<h2>
<a id="src-folder" class="anchor" href="#src-folder" aria-hidden="true"><span class="octicon octicon-link"></span></a>src folder</h2>

<p>Add the src folder from the .zip repository or replicate the folder structure below. 
<img src="http://irsgov.github.io/IDES-Data-Preparation-Java/images/image9.png" alt="Image 9"><br>
Figure 9</p>

<ol>
<li>Add code for FATCAPackager.java</li>
</ol>

<pre><code>package fatca;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.net.URI;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.Enumeration;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.Deflater;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.datatype.DatatypeConstants;
import javax.xml.datatype.XMLGregorianCalendar;

import org.apache.log4j.Logger;

import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;

import fatca.idessenderfilemetadata.FATCAEntCommunicationTypeCdType;
import fatca.idessenderfilemetadata.FATCAIDESSenderFileMetadataType;

public class FATCAPackager {
    public static String AES_TRANSFORMATION = "AES/ECB/PKCS5Padding";
    public static String RSA_TRANSFORMATION = "RSA";
    public static String SECRET_KEY_ALGO = "AES";
    public static int SECRET_KEY_SIZE = 256;

    public static String metadataEmailAddress="none@email.com";
    public static int bufSize = 64 * 1024;

    public static boolean isCanonicalization = true;

    protected static Logger logger = Logger.getLogger(new Object(){}.getClass().getEnclosingClass().getName());

    protected FATCAXmlSigner signer = new FATCAXmlSigner();
    protected Long fileId = 0L;
    protected fatca.idessenderfilemetadata.ObjectFactory objFMetadata = new fatca.idessenderfilemetadata.ObjectFactory();
    protected SimpleDateFormat sdfFileName = new SimpleDateFormat("yyyyMMdd'T'HHmmssSSS'Z'");
    protected SimpleDateFormat sdfFileCreateTs = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");

    protected int maxAttempts = 5;

    protected boolean aes(int opmode, String inputFile, String outputFile, SecretKey secretKey) throws Exception {
        logger.debug("--&gt; aes(). opmode=" + (opmode==Cipher.ENCRYPT_MODE?"ENCRYPT":"DECRYPT") + 
            ", inputFile=" + inputFile + ", outputFile=" + outputFile);
        if (opmode != Cipher.ENCRYPT_MODE &amp;&amp; opmode != Cipher.DECRYPT_MODE)
            throw new Exception("Invalid opmode " + opmode + ". Allowed opmodes are Cipher.ENCRYPT_MODE or Cipher.DECRYPT_MODE");
        boolean ret = false;
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        int len;
        byte[] output = null;
        byte[] buf = new byte[bufSize];
        Cipher cipher;
        try {
            cipher = Cipher.getInstance(AES_TRANSFORMATION);
            cipher.init(opmode, secretKey);
            bis = new BufferedInputStream(new FileInputStream(inputFile));
            bos = new BufferedOutputStream(new FileOutputStream(outputFile));
            while((len = bis.read(buf)) != -1) {
                //output = cipher.update(Arrays.copyOf(buf, len));
                output = cipher.update(buf, 0, len);
                if (output.length &gt; 0)
                    bos.write(output);
            }
            output = cipher.doFinal();
            if (output.length &gt; 0)
                bos.write(output);
            bos.close(); bos = null;
            bis.close(); bis = null; 
            ret = true;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        } finally {
            if (bis != null) try{bis.close();}catch(Exception e) {}
            if (bos != null) try{bos.close();}catch(Exception e) {}
        }
        logger.debug("&lt;-- aes()");
        return ret;
    }

    protected boolean encrypt(String zippedSignedPlainTextFile, String cipherTextOutFile, Certificate[] receiversPublicCert,
            String[] encryptedAESKeyOutFiles) throws Exception {
        logger.debug("--&gt; encrypt(). zippedSignedPlainTextFile=" + zippedSignedPlainTextFile + ", cipherTextOutFile=" + cipherTextOutFile);
        PublicKey[] pubkeys = new PublicKey[receiversPublicCert.length];
        for (int i = 0; i &lt; receiversPublicCert.length; i++)
            pubkeys[i] = receiversPublicCert[i].getPublicKey();
        boolean flag = encrypt(zippedSignedPlainTextFile, cipherTextOutFile, pubkeys, encryptedAESKeyOutFiles);
        logger.debug("&lt;-- encrypt()");
        return flag;
    }

    protected boolean encrypt(String zippedSignedPlainTextFile, String cipherTextOutFile, PublicKey[] receiversPublicKey,
            String[] encryptedAESKeyOutFiles) throws Exception {
        logger.debug("--&gt; encrypt(). zippedSignedPlainTextFile=" + zippedSignedPlainTextFile + ", cipherTextOutFile" + cipherTextOutFile);
        boolean ret = false;
        SecretKey skey = null;
        KeyGenerator generator;
        byte[] encryptedAESKeyBuf;
        BufferedOutputStream bos = null;
        Cipher cipher = null;
        try {
            generator = KeyGenerator.getInstance(SECRET_KEY_ALGO);
            generator.init(SECRET_KEY_SIZE);
            skey = generator.generateKey();
            ret = aes(Cipher.ENCRYPT_MODE, zippedSignedPlainTextFile, cipherTextOutFile, skey);
            if (ret) {
                for (int i = 0; i &lt; receiversPublicKey.length &amp;&amp; i &lt; encryptedAESKeyOutFiles.length; i++) {
                    if (cipher == null)
                        cipher = Cipher.getInstance(RSA_TRANSFORMATION);
                    cipher.init(Cipher.WRAP_MODE, receiversPublicKey[i]);
                    encryptedAESKeyBuf = cipher.wrap(skey);
                    bos = new BufferedOutputStream(new FileOutputStream(encryptedAESKeyOutFiles[i]));
                    bos.write(encryptedAESKeyBuf);
                    bos.close(); bos = null;
                }
                ret = true;
            }
        } catch(Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        } finally {
            if (bos != null) try{bos.close();}catch(Exception e) {}
        }
        logger.debug("&lt;-- encrypt)");
        return ret;
    }

    protected boolean renameZipEntry(String zipFile, String entryName, String newEntryName) throws Exception {
        logger.debug("--&gt; renameZipEntry(). zipFile=" + zipFile + ", entryName=" + entryName + ", newEntryName=" + newEntryName);
        boolean ret = false;
        Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;(); 
        props.put("create", "false"); 
        try {
            URI zipDisk = URI.create("jar:" + new File(zipFile).toURI());
            FileSystem zipfs = FileSystems.newFileSystem(zipDisk, props);
            Path pathInZipfile = zipfs.getPath(entryName);
            Path renamedZipEntry = zipfs.getPath(newEntryName);
            Files.move(pathInZipfile,renamedZipEntry, StandardCopyOption.ATOMIC_MOVE);
            zipfs.close();
            ret = true;
        } catch(Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        }
        logger.debug("&lt;-- renameZipEntry()");
        return ret;
    }

    protected boolean renameZipEntries(String zipFile, String[] entryNames, String[] newEntryNames) throws Exception {
        if (logger.isDebugEnabled()) {
            StringBuilder sb = new StringBuilder("--&gt; renameZipEntries()");
            sb.append(", zipFile=");
            sb.append(zipFile);
            sb.append(", entryNames=[");
            for (int i = 0; i &lt; entryNames.length; i++) {
                if (i &gt; 0) sb.append(",");
                sb.append(entryNames[i]);
            }
            sb.append("], newEntryNames=[");
            for (int i = 0; i &lt; newEntryNames.length; i++) {
                if (i &gt; 0) sb.append(",");
                sb.append(newEntryNames[i]);
            }
            sb.append("]");
            logger.debug(sb.toString());
        }
        boolean ret = false;
        if (entryNames.length != newEntryNames.length)
            throw new Exception("renameZipEntries entryNames and newEntryNames length should be same");
        Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;(); 
        props.put("create", "false"); 
        try {
            URI zipDisk = URI.create("jar:" + new File(zipFile).toURI());
            FileSystem zipfs = FileSystems.newFileSystem(zipDisk, props);
            Path pathInZipfile, renamedZipEntry;
            for (int i = 0; i &lt; entryNames.length; i++) {
                pathInZipfile = zipfs.getPath(entryNames[i]);
                renamedZipEntry = zipfs.getPath(newEntryNames[i]);
                Files.move(pathInZipfile,renamedZipEntry, StandardCopyOption.ATOMIC_MOVE);
            }
            zipfs.close();
            ret = true;
        } catch(Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        }
        logger.debug("&lt;-- renameZipEntries()");
        return ret;
    }

    protected boolean createZipFile(String[] inFiles, String outFile) throws Exception {
        if (logger.isDebugEnabled()) {
            StringBuilder sb = new StringBuilder("--&gt; createZipFile()");
            sb.append(", inFiles=[");
            for (int i = 0; i &lt; inFiles.length; i++) {
                if (i &gt; 0) sb.append(",");
                sb.append(inFiles[i]);
            }
            sb.append("], outFile=");
            sb.append(outFile);
            logger.debug(sb.toString());
        }
        BufferedInputStream bis = null;
        ZipOutputStream zos = null;
        ZipEntry zipEntry;
        int len;
        boolean ret = false;
        String infile;
        byte[] buf = new byte[bufSize];
        try {
            zos = new ZipOutputStream(new FileOutputStream(outFile));
            zos.setLevel(Deflater.BEST_COMPRESSION);
            for (int i = 0; i &lt; inFiles.length; i++) {
                // drop folder names
                infile = inFiles[i];
                len = infile.lastIndexOf("/");
                if (len == -1)
                    len = infile.lastIndexOf("\\");
                if (len != -1)
                    infile = infile.substring(len+1);
                zipEntry = new ZipEntry(infile);
                zos.putNextEntry(zipEntry);
                bis = new BufferedInputStream(new FileInputStream(inFiles[i]));
                while((len = bis.read(buf)) != -1)
                    zos.write(buf, 0, len);
                bis.close(); bis = null;
                zos.closeEntry();
            }
            zos.close(); zos = null;
            ret = true;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        } finally {
            if (bis != null) try{bis.close();}catch(Exception e) {}
            if (zos != null) try{zos.close();}catch(Exception e) {}
        }
        logger.debug("&lt;-- createZipFile()");
        return ret;
    }

    protected ArrayList&lt;String&gt; unzipFile(String inFile) throws Exception {
        return unzipFile(inFile, null);
    }

    protected ArrayList&lt;String&gt; unzipFile(String inFile, String extractFolder) throws Exception {
        logger.debug("--&gt; unzipFile(). inFile=" + inFile + ", extractFolder=" + extractFolder);
        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;
        int len;
        ZipFile zipFile = null;
        Enumeration&lt;? extends ZipEntry&gt; entries;
        ZipEntry entry;
        ArrayList&lt;String&gt; entryList = null;
        byte[] buf = new byte[bufSize];
        String outFile;
        try {
            if (extractFolder == null)
                extractFolder = ".";
            if (!extractFolder.endsWith("/") &amp;&amp; !extractFolder.endsWith("\\"))
                extractFolder += "/";
            zipFile = new ZipFile(inFile);
            entries = zipFile.entries();
            while (entries.hasMoreElements()) {
                if (entryList == null)
                    entryList = new ArrayList&lt;String&gt;();
                entry = entries.nextElement();
                outFile = extractFolder + entry.getName();
                entryList.add(outFile);
                bis = new BufferedInputStream(zipFile.getInputStream(entry));
                bos = new BufferedOutputStream(new FileOutputStream(outFile));
                while((len = bis.read(buf)) != -1)
                    bos.write(buf, 0, len);
                bos.close(); bos = null;
                bis.close(); bis = null;
            }
            zipFile.close(); zipFile = null;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        } finally {
            if (bis != null) try{bis.close();}catch(Exception e) {}
            if (bos != null) try{bos.close();}catch(Exception e) {}
            if (zipFile != null) try{zipFile.close();}catch(Exception e) {}
        }
        logger.debug("&lt;-- unzipFile()");
        return entryList;
    }

    //_Payload.xml,_Metadata.xml, _Payload.zip, _Key, _Payload
    protected String getFileName(String senderGiin, String filename) throws Exception {
        synchronized (fileId) {
            logger.debug("--&gt; getFileName(). senderGiin=" + senderGiin + ", filename=" + filename);
            if (fileId == Long.MAX_VALUE) fileId = 0L;
            String xmlfilename = senderGiin + "_" + fileId++ + filename;
            File file = new File(xmlfilename);
            int attempts = maxAttempts;
            while(!file.createNewFile() &amp;&amp; attempts-- &gt; 0) {
                xmlfilename = senderGiin + "_" + fileId++ + filename;
                file = new File(xmlfilename);
            }
            if (attempts &lt;= 0)
                throw new Exception ("Unable to getFileName() - file=" + file.getAbsolutePath());
            logger.debug("&lt;-- getFileName()");
            return xmlfilename;
        }
    }

    protected String getIDESFileName(String senderGiin) throws Exception {
        synchronized (fileId) {
            logger.debug("--&gt; getIDESFileName(). senderGiin=" + senderGiin);
            Date date = new Date();
            String outfile = sdfFileName.format(date) + "_" + senderGiin + ".zip";
            File file = new File(outfile);
            int attempts = maxAttempts;
            while (!file.createNewFile() &amp;&amp; attempts-- &gt; 0) {
                outfile = sdfFileName.format(new Date()) + "_" + senderGiin + ".zip";
                file = new File(outfile);
            }
            if (attempts &lt;= 0)
                throw new Exception ("Unable to getFileName() - file=" + file.getAbsolutePath());
            logger.debug("&lt;-- getIDESFileName()");
            return outfile;
        }
    }

    protected XMLGregorianCalendar genTaxYear(int year) {
        XMLGregorianCalendar taxyear = new XMLGregorianCalendarImpl(new GregorianCalendar());
        taxyear.setTimezone(DatatypeConstants.FIELD_UNDEFINED);
        taxyear.setTime(DatatypeConstants.FIELD_UNDEFINED, DatatypeConstants.FIELD_UNDEFINED, DatatypeConstants.FIELD_UNDEFINED);
        taxyear.setDay(DatatypeConstants.FIELD_UNDEFINED);
        taxyear.setMonth(DatatypeConstants.FIELD_UNDEFINED);
        taxyear.setYear(year);
        return taxyear;
    }

    protected String getFileName(String filename) {
        File f = new File(filename);
        return f.getName();
    }

    public String signAndCreatePkg(String unsignedXml, PrivateKey senderPrivateKey, X509Certificate senderPublicCert,
            String senderGiin, String receiverGiin, X509Certificate receiverPublicCert, int taxyear) throws Exception {
        logger.debug("--&gt; signAndCreatePkg(). unsignedXml=" + unsignedXml + ", senderGiin=" + senderGiin +
                ", receiverGiin=" + receiverGiin + ", taxyear=" + taxyear);
        String signedxml = unsignedXml + ".signed";
        boolean success = false;
        String ret = null;
        if (isCanonicalization)
            success = signer.signStreamingWithCanonicalization(unsignedXml, signedxml, senderPrivateKey, senderPublicCert);
        else
            success = signer.signStreaming(unsignedXml, signedxml, senderPrivateKey, senderPublicCert);
        if (success)
            ret = createPkgWithApprover(signedxml, senderGiin, receiverGiin, receiverPublicCert, null, null, taxyear);
        logger.debug("&lt;-- signAndCreatePkg()");
        return ret;
    }

    public String signAndCreatePkgWithApprover(String unsignedxml, PrivateKey senderPrivateKey, X509Certificate senderPublicCert,
            String senderGiin, String receiverGiin, X509Certificate receiverPublicCert, String approverGiin, 
            X509Certificate approvercert, int taxyear) throws Exception {
        logger.debug("--&gt; signAndCreatePkgWithApprover(). xmlfilename=" + unsignedxml + ", senderGiin=" + senderGiin +
                ", receiverGiin=" + receiverGiin + ", approverGiin=" + approverGiin + ", taxyear=" + taxyear);
        String signedxml = unsignedxml + ".signed";
        boolean success = false;
        String ret = null;
        if (isCanonicalization)
            success = signer.signStreamingWithCanonicalization(unsignedxml, signedxml, senderPrivateKey, senderPublicCert);
        else
            success = signer.signStreaming(unsignedxml, signedxml, senderPrivateKey, senderPublicCert);
        if (success)
            ret = createPkgWithApprover(signedxml, senderGiin, receiverGiin, receiverPublicCert, approverGiin, approvercert, taxyear);
        logger.debug("&lt;-- signAndCreatePkgWithApprover()");
        return ret;
    }

    public String createPkg(String signedXmlFile, String senderGiin, String receiverGiin,  
            X509Certificate receiverPublicCert, int taxyear) throws Exception {
        return createPkgWithApprover(signedXmlFile, senderGiin, receiverGiin, receiverPublicCert, null, null, taxyear);
    }

    public String createPkgWithApprover(String signedXmlFile, String senderGiin, String receiverGiin,  
            X509Certificate receiverPublicCert, String approverGiin, 
            X509Certificate approvercert, int taxyear) throws Exception {
        logger.debug("--&gt; createPkgWithApprover(). signedXmlFile= " + signedXmlFile + ", senderGiin=" + senderGiin + 
                ", receiverGiin=" + receiverGiin + ", approverGiin=" + approverGiin);
        String idesOutFile = null;
        try {
            Date date = new Date();
            String metadatafile = getFileName(senderGiin, "_Metadata.xml");
            JAXBContext jaxbCtxMetadata = JAXBContext.newInstance(FATCAIDESSenderFileMetadataType.class);            
            Marshaller mrshler = jaxbCtxMetadata.createMarshaller();
            mrshler.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);

            FATCAIDESSenderFileMetadataType metadata = objFMetadata.createFATCAIDESSenderFileMetadataType();
            JAXBElement&lt;FATCAIDESSenderFileMetadataType&gt; jaxbElemMetadata = objFMetadata.createFATCAIDESSenderFileMetadata(metadata);

            metadata.setFATCAEntCommunicationTypeCd(FATCAEntCommunicationTypeCdType.RPT);
            metadata.setFATCAEntitySenderId(senderGiin);
            metadata.setFileRevisionInd(false);
            String senderFileId = getIDESFileName(senderGiin);
            File file = new File(senderFileId);
            metadata.setSenderFileId(file.getName());
            metadata.setTaxYear(genTaxYear(taxyear));
            metadata.setFATCAEntityReceiverId(receiverGiin);
            metadata.setFileCreateTs(sdfFileCreateTs.format(date));
            metadata.setSenderContactEmailAddressTxt(metadataEmailAddress);
            FileWriter fw = new FileWriter(metadatafile);
            mrshler.marshal(jaxbElemMetadata, fw);
            fw.close();
            String xmlzipFilename;
            boolean success = false;
            xmlzipFilename = getFileName(senderGiin, "_Payload.zip");
            success = createZipFile(new String[]{signedXmlFile}, xmlzipFilename);
            if (success)
                success = renameZipEntry(xmlzipFilename, getFileName(signedXmlFile), senderGiin + "_Payload.xml");
            if (!success)
                throw new Exception("uanble to create " + xmlzipFilename);
            idesOutFile = senderFileId;
            Certificate[] certs = null;
            String[] encryptedAESKeyOutFiles = null;
            if (approvercert != null &amp;&amp; approverGiin != null) {
                certs = new X509Certificate[] {receiverPublicCert, approvercert};
                encryptedAESKeyOutFiles = new String[]{getFileName(receiverGiin, "_Key"), getFileName(approverGiin, "_Key")};
            } else if (receiverPublicCert != null){
                certs = new X509Certificate[] {receiverPublicCert};
                encryptedAESKeyOutFiles = new String[]{getFileName(receiverGiin, "_Key")};
            } else
                throw new Exception ("both approvingEntityCert and receivingEntityCert is null");
            String xmlZippedEncryptedFile = getFileName(senderGiin, "_Payload");
            success = encrypt(xmlzipFilename, xmlZippedEncryptedFile, certs, encryptedAESKeyOutFiles);
            if (! success)
                throw new Exception("encryption failed. xmlzipFilename=" + xmlzipFilename);
            int count = 0;
            String[] infiles = new String[encryptedAESKeyOutFiles.length + 2];
            for (count = 0; count &lt; encryptedAESKeyOutFiles.length; count++)
                infiles[count] = encryptedAESKeyOutFiles[count];
            infiles[count++] =  xmlZippedEncryptedFile;
            infiles[count] = metadatafile;
            success = createZipFile(infiles, idesOutFile);
            if (success) {
                if (encryptedAESKeyOutFiles.length == 2)
                    success = renameZipEntries(idesOutFile, new String[]{getFileName(xmlZippedEncryptedFile), getFileName(metadatafile), 
                            getFileName(encryptedAESKeyOutFiles[0]), getFileName(encryptedAESKeyOutFiles[1])},
                            new String[]{senderGiin + "_Payload", senderGiin + "_Metadata.xml", 
                            receiverGiin + "_Key", approverGiin + "_Key"});
                else
                    success = renameZipEntries(idesOutFile, new String[]{getFileName(xmlZippedEncryptedFile), getFileName(metadatafile), 
                        getFileName(encryptedAESKeyOutFiles[0])},
                        new String[]{senderGiin + "_Payload", senderGiin + "_Metadata.xml", 
                        receiverGiin + "_Key"});
            }
            if (!success)
                throw new Exception("unable to create zip file " + idesOutFile);
            for (int i = 0; i &lt; infiles.length; i++)
                deleteFile(infiles[i]);
            deleteFile(xmlzipFilename);
            //deleteFile(signedXmlFile);
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        }
        logger.debug("&lt;-- createPkgWithApprover()");
        return idesOutFile;
    }

    protected boolean decrypt(String cipherTextFile, String encryptedAESKeyFile, String zippedSignedPlainTextFile, PrivateKey privkey) throws Exception {
        logger.debug("--&gt; decrypt(). cipherTextFile= " + cipherTextFile + ", encryptedAESKeyFile=" + encryptedAESKeyFile + 
                ", zippedSignedPlainTextFile=" + zippedSignedPlainTextFile);
        SecretKey skey;
        boolean ret = false;
        BufferedInputStream bis = null;
        byte[] buf, skeyBuf = null;
        int len, count;
        try {
            buf = new byte[bufSize];
            bis = new BufferedInputStream(new FileInputStream(encryptedAESKeyFile));
            while((len = bis.read(buf)) != -1) {
                if (skeyBuf == null) {
                    skeyBuf = new byte[len];
                    System.arraycopy(buf, 0, skeyBuf, 0, len);
                } else {
                    count = skeyBuf.length;
                    skeyBuf = Arrays.copyOf(skeyBuf, skeyBuf.length + len);
                    System.arraycopy(buf, 0, skeyBuf, count, len);
                }
            }
            bis.close(); bis = null;
            Cipher cipher = Cipher.getInstance(RSA_TRANSFORMATION);
            cipher.init(Cipher.UNWRAP_MODE, privkey);
            skey = (SecretKey)cipher.unwrap(skeyBuf, SECRET_KEY_ALGO, Cipher.SECRET_KEY);
            ret = aes(Cipher.DECRYPT_MODE, cipherTextFile, zippedSignedPlainTextFile, skey);
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw e;
        } finally {
            if (bis != null) try{bis.close();}catch(Exception e) {}
        }
        logger.debug("&lt;-- createPkgWithApprover()");
        return ret;
    }

    protected void deleteFile(String filename) {
        File file = new File(filename);
        int attempts = maxAttempts;
        while (file.exists() &amp;&amp; !file.delete() &amp;&amp; attempts--&gt;0)
            Thread.yield();
    }

    public boolean unpack(String idesPkgFile, String keystoreType, String keystoreFile, String keystorePwd, String keyPwd, String keyAlias) throws Exception {
        logger.debug("--&gt; unpack(). idesPkgFile=" + idesPkgFile + ", keystoreType=" + keystoreType + 
                ", keystoreFile=" + keystoreFile + ", keyAlias=" + keyAlias);
        PrivateKey privateKey = UtilShared.getPrivateKey(keystoreType, keystoreFile, keystorePwd, keyPwd, keyAlias);
        boolean flag = unpack (idesPkgFile, privateKey);
        logger.debug("&lt;-- unpack()");
        return flag;
    }

    public boolean unpack(String idesPkgFile, PrivateKey receiverPrivateKey) throws Exception {
        logger.debug("--&gt; unpack(). idesPkgFile=" + idesPkgFile);
        boolean flag = unpack(idesPkgFile, receiverPrivateKey, false);
        logger.debug("&lt;-- unpack()");
        return flag;
    }

    public boolean unpackForApprover(String idesPkgFile, String approverKeystoreType, String approverKeystoreFile, 
            String approverKeystorePwd, String approverKeyPwd, String approverKeyAlias) throws Exception {
        logger.debug("--&gt; unpackForApprover(). idesPkgFile=" + idesPkgFile + ", approverKeystoreType=" + approverKeystoreType + 
                ", approverKeystoreFile=" + approverKeystoreFile + ", approverKeyAlias=" + approverKeyAlias);
        PrivateKey approverPrivateKey = UtilShared.getPrivateKey(approverKeystoreType, approverKeystoreFile, approverKeystorePwd, approverKeyPwd, approverKeyAlias);
        boolean flag = unpackForApprover(idesPkgFile, approverPrivateKey);
        logger.debug("&lt;-- unpackForApprover()");
        return flag;
    }

    public boolean unpackForApprover(String idesPkgFile, PrivateKey approverPrivateKey) throws Exception {
        logger.debug("--&gt; unpackForApprover(). idesPkgFile=" + idesPkgFile);
        boolean flag = unpack(idesPkgFile, approverPrivateKey, true);
        logger.debug("&lt;-- unpackForApprover()");
        return flag;
    }

    protected boolean unpack(String idesPkgFile, PrivateKey privateKey, boolean isApprover) throws Exception {
        logger.debug("--&gt; unpack(). idesPkg=" + idesPkgFile + ", isApprover=" + isApprover);
        boolean ret = false;
        try {
            ArrayList&lt;String&gt; entryList = unzipFile(idesPkgFile);
            String approverKeyFile = null, receiverKeyFile = null, payloadFile = null, metadataFile = null,  receiverGiin = null, filename;
            // get metadata file
            for (int i = 0; i &lt; entryList.size(); i++) {
                filename = entryList.get(i);
                if (filename.contains("Metadata"))
                    metadataFile = filename;
                else if (filename.contains("Payload"))
                    payloadFile = filename;
                else if (filename.contains("Key")) {
                    if (receiverKeyFile == null)
                        receiverKeyFile = filename;
                    else
                        approverKeyFile = filename;
                }
            }
            if (metadataFile == null)
                throw new Exception("Invalid package - no metadata file");
            if (payloadFile == null)
                throw new Exception("Invalid package - no payload file");

            if (approverKeyFile != null) {
                JAXBContext jaxbCtxMetadata = JAXBContext.newInstance("fatca.idessenderfilemetadata");
                Unmarshaller unmrshlr = jaxbCtxMetadata.createUnmarshaller();
                Object obj = unmrshlr.unmarshal(new File(metadataFile));;
                if (obj instanceof JAXBElement&lt;?&gt;) {
                    @SuppressWarnings("unchecked")
                    JAXBElement&lt;FATCAIDESSenderFileMetadataType&gt; jaxbElem = 
                        (JAXBElement&lt;FATCAIDESSenderFileMetadataType&gt;)obj;
                    FATCAIDESSenderFileMetadataType metadataObj = jaxbElem.getValue();
                    receiverGiin = metadataObj.getFATCAEntityReceiverId();
                    if (!receiverKeyFile.contains(receiverGiin)) {
                        filename = approverKeyFile;
                        approverKeyFile = receiverKeyFile;
                        receiverKeyFile = filename;
                    }
                }
            } else if (receiverKeyFile != null)
                receiverGiin = receiverKeyFile.substring(0, receiverKeyFile.length() - "_Key".length());
            if (receiverGiin == null)
                throw new Exception("Invalid metadata file - missing receiver giin or corrupt zip file - no reveiverKeyFile");
            if (isApprover &amp;&amp; approverKeyFile == null)
                throw new Exception("Invalid package - no approverKeyFile");
            String zippedSignedPlainTextFile = getFileName(receiverGiin, "_Payload.zip");
            if (approverKeyFile != null &amp;&amp; isApprover)
                ret = decrypt(payloadFile, approverKeyFile, zippedSignedPlainTextFile, privateKey);
            else
                ret = decrypt(payloadFile, receiverKeyFile, zippedSignedPlainTextFile, privateKey);

            if (ret) {
                if (unzipFile(zippedSignedPlainTextFile) == null)
                    ret = false;
                else
                    deleteFile(zippedSignedPlainTextFile);
            }
            deleteFile(payloadFile);
            //deleteFile(metadataFile);
            deleteFile(receiverKeyFile);
            if (approverKeyFile != null)
                deleteFile(approverKeyFile);
        } catch(Exception e) {
            logger.error(e.getMessage());
            throw e;
        }
        logger.debug("&lt;-- unpack()");
        return ret;
    }
}
</code></pre>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">IDES Data Preparation - Java maintained by <a href="https://github.com/IRSgov">IRSgov</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
