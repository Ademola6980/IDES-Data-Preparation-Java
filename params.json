{"name":"IDES Data Preparation - Java","tagline":"","body":"## IDES Data Preparation\r\nThe International Data Exchange Service (IDES) is a secure managed file transfer service that allows financial institutions and tax authorities to securely send information on financial accounts held by U.S. taxpayers in accordance with the Foreign Account Tax Compliance Act (FATCA). Files transmitted via IDES must be encrypted and packaged in accordance with published data preparation instructions.  The data preparation process is an important step to ensure that information transmitted via IDES conforms to U.S security standards to safeguard sensitive information.\r\n\r\nThe IDES Data Preparation Java project repository demonstrates a sample working application built using Java inside of [Eclipse](http://www.eclipse.org/).  An application was also developed using .Net, see [IDES Data Preparation .Net]  (http://irsgov.github.io/IDES-Data-Preparation-Dot-Net) for more information.\r\n\r\nThe example explains how to use the code to develop an application that will create an IDES data packet and decrypt notifications. The project starts with a validated FATCA XML file. The application does not validate the XML or metadata schemas. The sample application will digitally sign, encrypt, compress, and archive the data packet into a compliant .ZIP format.  \r\n\r\nPlease note that there are many open market tools that produce the same results; however, the IRS does not endorse any commercial products, including the frameworks used in the example.  \r\n\r\n### Application Setup\r\n\r\nThe sample application was created using Eclipse 4.4.1 and JRE version 1.8.0_40. \r\n\r\nThis repository includes a .zip file that contains several files necessary to this sample application. While some files can be copied and pasted from this guide, some must be downloaded from the .zip file and placed as indicated by the guide.\r\n\r\nKeystore - This folder contains a set of .jks files containing self-signed test public and private keys used by the application.\r\n\r\nlib - This folder contains the log4j-1.2.16.jar file which provides the console logging for the application.\r\n\r\ngenerated - This folder has a set of .java files related to the metadata used by the application.\r\n\r\nsrc - This folder has the main set of .java files, including testmain.java which is used to start the application.\r\n\r\n000000.00000.TA.124_0_Payload.xml - This is the FATCA XML that will be signed, encrypted, and packaged by the application. This is a test file for the application and is not intended to portray a specific business case.\r\n\r\n### Create a New Project  \r\n\r\nOpen **Eclipse**, select **New**, select **Java Project**. \r\n\r\n![Image 1](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image1.png)  \r\nFigure 1   \r\n \r\nEnter **IDESDataPreparation** for the Project Name and select the JRE that you will use. The sample is using jre1.8.0_40. Click the **Next** button.\r\n\r\n![Image 2](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image2.png)  \r\nFigure 2     \r\n\r\nClick **Finish**, these will be set up later\r\n\r\n![Image 3](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image3.png)  \r\nFigure 3\r\n\r\nThe Eclipse project with the default settings:\r\n![Image 4](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image4.png)  \r\nFigure 4\r\n\r\nThe file system for the new project:\r\n![Image 5](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image5.png)  \r\nFigure 5\r\n\r\n##generated folder\r\nAdd the generated folder from the .zip repository or replicate the folder structure below. \r\n![Image 6](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image6.png)  \r\nFigure 6\r\n\r\n1. Add code for FATCAEntCommunicationTypeCdType.java\r\n```\r\n//\r\n// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 \r\n// See <a href=\"http://java.sun.com/xml/jaxb\">http://java.sun.com/xml/jaxb</a> \r\n// Any modifications to this file will be lost upon recompilation of the source schema. \r\n// Generated on: 2014.11.05 at 11:20:51 AM EST \r\n//\r\n\r\n\r\npackage fatca.idessenderfilemetadata;\r\n\r\nimport javax.xml.bind.annotation.XmlEnum;\r\nimport javax.xml.bind.annotation.XmlType;\r\n\r\n\r\n/**\r\n * <p>Java class for FATCAEntCommunicationTypeCdType.\r\n * \r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n * <p>\r\n * <pre>\r\n * &lt;simpleType name=\"FATCAEntCommunicationTypeCdType\">\r\n *   &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}string\">\r\n *     &lt;enumeration value=\"NTF\"/>\r\n *     &lt;enumeration value=\"RPT\"/>\r\n *   &lt;/restriction>\r\n * &lt;/simpleType>\r\n * </pre>\r\n * \r\n */\r\n@XmlType(name = \"FATCAEntCommunicationTypeCdType\")\r\n@XmlEnum\r\npublic enum FATCAEntCommunicationTypeCdType {\r\n\r\n\r\n    /**\r\n     * FATCA_NOTIFICATION - FATCA Notification communication\r\n     * \r\n     */\r\n    NTF,\r\n\r\n    /**\r\n     * FATCA_REPORT - FATCA Report communication\r\n     * \r\n     */\r\n    RPT;\r\n\r\n    public String value() {\r\n        return name();\r\n    }\r\n\r\n    public static FATCAEntCommunicationTypeCdType fromValue(String v) {\r\n        return valueOf(v);\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n2. Add code for FATCAIDESSenderFileMetadataType.java\r\n```\r\n//\r\n// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 \r\n// See <a href=\"http://java.sun.com/xml/jaxb\">http://java.sun.com/xml/jaxb</a> \r\n// Any modifications to this file will be lost upon recompilation of the source schema. \r\n// Generated on: 2014.11.05 at 11:20:51 AM EST \r\n//\r\n\r\n\r\npackage fatca.idessenderfilemetadata;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\nimport javax.xml.datatype.XMLGregorianCalendar;\r\n\r\n\r\n/**\r\n * \r\n * \t\t\t\t\r\n * <pre>\r\n * &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Component xmlns=\"urn:fatca:idessenderfilemetadata\" xmlns:xmime=\"http://www.w3.org/2005/05/xmlmime\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"&gt;&lt;DictionaryEntryNm&gt;FATCA IDES Sender File Metadata Type&lt;/DictionaryEntryNm&gt;&lt;MajorVersionNum&gt;1&lt;/MajorVersionNum&gt;&lt;MinorVersionNum&gt;0&lt;/MinorVersionNum&gt;&lt;VersionEffectiveBeginDt&gt;2014-08-29&lt;/VersionEffectiveBeginDt&gt;&lt;VersionDescriptionTxt&gt;Initial Version&lt;/VersionDescriptionTxt&gt;&lt;Description&gt;Type for a group that defines the information contained in the FATCA IDES Sender File Metadata&lt;/Description&gt;\r\n * \t\t\t\t&lt;/Component&gt;\r\n * </pre>\r\n * \r\n * \t\t\t\r\n * \r\n * <p>Java class for FATCAIDESSenderFileMetadataType complex type.\r\n * \r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n * \r\n * <pre>\r\n * &lt;complexType name=\"FATCAIDESSenderFileMetadataType\">\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;sequence>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}FATCAEntitySenderId\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}FATCAEntityReceiverId\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}FATCAEntCommunicationTypeCd\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}SenderFileId\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}FileCreateTs\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}TaxYear\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}FileRevisionInd\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}OriginalIDESTransmissionId\" minOccurs=\"0\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}SenderContactEmailAddressTxt\" minOccurs=\"0\"/>\r\n *       &lt;/sequence>\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n * \r\n * \r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"FATCAIDESSenderFileMetadataType\", propOrder = {\r\n    \"fatcaEntitySenderId\",\r\n    \"fatcaEntityReceiverId\",\r\n    \"fatcaEntCommunicationTypeCd\",\r\n    \"senderFileId\",\r\n    \"fileCreateTs\",\r\n    \"taxYear\",\r\n    \"fileRevisionInd\",\r\n    \"originalIDESTransmissionId\",\r\n    \"senderContactEmailAddressTxt\"\r\n})\r\npublic class FATCAIDESSenderFileMetadataType {\r\n\r\n    @XmlElement(name = \"FATCAEntitySenderId\", required = true)\r\n    protected String fatcaEntitySenderId;\r\n    @XmlElement(name = \"FATCAEntityReceiverId\", required = true)\r\n    protected String fatcaEntityReceiverId;\r\n    @XmlElement(name = \"FATCAEntCommunicationTypeCd\", required = true)\r\n    protected FATCAEntCommunicationTypeCdType fatcaEntCommunicationTypeCd;\r\n    @XmlElement(name = \"SenderFileId\", required = true)\r\n    protected String senderFileId;\r\n    @XmlElement(name = \"FileCreateTs\", required = true)\r\n    protected String fileCreateTs;\r\n    @XmlElement(name = \"TaxYear\", required = true)\r\n    protected XMLGregorianCalendar taxYear;\r\n    @XmlElement(name = \"FileRevisionInd\")\r\n    protected boolean fileRevisionInd;\r\n    @XmlElement(name = \"OriginalIDESTransmissionId\")\r\n    protected String originalIDESTransmissionId;\r\n    @XmlElement(name = \"SenderContactEmailAddressTxt\")\r\n    protected String senderContactEmailAddressTxt;\r\n\r\n    /**\r\n     * Gets the value of the fatcaEntitySenderId property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public String getFATCAEntitySenderId() {\r\n        return fatcaEntitySenderId;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the fatcaEntitySenderId property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public void setFATCAEntitySenderId(String value) {\r\n        this.fatcaEntitySenderId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fatcaEntityReceiverId property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public String getFATCAEntityReceiverId() {\r\n        return fatcaEntityReceiverId;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the fatcaEntityReceiverId property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public void setFATCAEntityReceiverId(String value) {\r\n        this.fatcaEntityReceiverId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fatcaEntCommunicationTypeCd property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link FATCAEntCommunicationTypeCdType }\r\n     *     \r\n     */\r\n    public FATCAEntCommunicationTypeCdType getFATCAEntCommunicationTypeCd() {\r\n        return fatcaEntCommunicationTypeCd;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the fatcaEntCommunicationTypeCd property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link FATCAEntCommunicationTypeCdType }\r\n     *     \r\n     */\r\n    public void setFATCAEntCommunicationTypeCd(FATCAEntCommunicationTypeCdType value) {\r\n        this.fatcaEntCommunicationTypeCd = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the senderFileId property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public String getSenderFileId() {\r\n        return senderFileId;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the senderFileId property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public void setSenderFileId(String value) {\r\n        this.senderFileId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fileCreateTs property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public String getFileCreateTs() {\r\n        return fileCreateTs;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the fileCreateTs property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public void setFileCreateTs(String value) {\r\n        this.fileCreateTs = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the taxYear property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link XMLGregorianCalendar }\r\n     *     \r\n     */\r\n    public XMLGregorianCalendar getTaxYear() {\r\n        return taxYear;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the taxYear property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link XMLGregorianCalendar }\r\n     *     \r\n     */\r\n    public void setTaxYear(XMLGregorianCalendar value) {\r\n        this.taxYear = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fileRevisionInd property.\r\n     * \r\n     */\r\n    public boolean isFileRevisionInd() {\r\n        return fileRevisionInd;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the fileRevisionInd property.\r\n     * \r\n     */\r\n    public void setFileRevisionInd(boolean value) {\r\n        this.fileRevisionInd = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the originalIDESTransmissionId property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public String getOriginalIDESTransmissionId() {\r\n        return originalIDESTransmissionId;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the originalIDESTransmissionId property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public void setOriginalIDESTransmissionId(String value) {\r\n        this.originalIDESTransmissionId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the senderContactEmailAddressTxt property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public String getSenderContactEmailAddressTxt() {\r\n        return senderContactEmailAddressTxt;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the senderContactEmailAddressTxt property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public void setSenderContactEmailAddressTxt(String value) {\r\n        this.senderContactEmailAddressTxt = value;\r\n    }\r\n\r\n}\r\n\r\n3. Add code for ObjectFactory.java\r\n```\r\n//\r\n// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 \r\n// See <a href=\"http://java.sun.com/xml/jaxb\">http://java.sun.com/xml/jaxb</a> \r\n// Any modifications to this file will be lost upon recompilation of the source schema. \r\n// Generated on: 2014.11.05 at 11:20:51 AM EST \r\n//\r\n\r\n\r\npackage fatca.idessenderfilemetadata;\r\n\r\nimport javax.xml.bind.JAXBElement;\r\nimport javax.xml.bind.annotation.XmlElementDecl;\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\nimport javax.xml.datatype.XMLGregorianCalendar;\r\nimport javax.xml.namespace.QName;\r\n\r\n\r\n/**\r\n * This object contains factory methods for each \r\n * Java content interface and Java element interface \r\n * generated in the fatca.idessenderfilemetadata package. \r\n * <p>An ObjectFactory allows you to programatically \r\n * construct new instances of the Java representation \r\n * for XML content. The Java representation of XML \r\n * content can consist of schema derived interfaces \r\n * and classes representing the binding of schema \r\n * type definitions, element declarations and model \r\n * groups.  Factory methods for each of these are \r\n * provided in this class.\r\n * \r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    private final static QName _SenderFileId_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"SenderFileId\");\r\n    private final static QName _FATCAEntCommunicationTypeCd_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"FATCAEntCommunicationTypeCd\");\r\n    private final static QName _TaxYear_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"TaxYear\");\r\n    private final static QName _FileRevisionInd_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"FileRevisionInd\");\r\n    private final static QName _FATCAIDESSenderFileMetadata_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"FATCAIDESSenderFileMetadata\");\r\n    private final static QName _SenderContactEmailAddressTxt_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"SenderContactEmailAddressTxt\");\r\n    private final static QName _FATCAEntitySenderId_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"FATCAEntitySenderId\");\r\n    private final static QName _FATCAEntityReceiverId_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"FATCAEntityReceiverId\");\r\n    private final static QName _OriginalIDESTransmissionId_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"OriginalIDESTransmissionId\");\r\n    private final static QName _FileCreateTs_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"FileCreateTs\");\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fatca.idessenderfilemetadata\r\n     * \r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link FATCAIDESSenderFileMetadataType }\r\n     * \r\n     */\r\n    public FATCAIDESSenderFileMetadataType createFATCAIDESSenderFileMetadataType() {\r\n        return new FATCAIDESSenderFileMetadataType();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"SenderFileId\")\r\n    public JAXBElement<String> createSenderFileId(String value) {\r\n        return new JAXBElement<String>(_SenderFileId_QNAME, String.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link FATCAEntCommunicationTypeCdType }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"FATCAEntCommunicationTypeCd\")\r\n    public JAXBElement<FATCAEntCommunicationTypeCdType> createFATCAEntCommunicationTypeCd(FATCAEntCommunicationTypeCdType value) {\r\n        return new JAXBElement<FATCAEntCommunicationTypeCdType>(_FATCAEntCommunicationTypeCd_QNAME, FATCAEntCommunicationTypeCdType.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link XMLGregorianCalendar }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"TaxYear\")\r\n    public JAXBElement<XMLGregorianCalendar> createTaxYear(XMLGregorianCalendar value) {\r\n        return new JAXBElement<XMLGregorianCalendar>(_TaxYear_QNAME, XMLGregorianCalendar.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link Boolean }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"FileRevisionInd\")\r\n    public JAXBElement<Boolean> createFileRevisionInd(Boolean value) {\r\n        return new JAXBElement<Boolean>(_FileRevisionInd_QNAME, Boolean.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link FATCAIDESSenderFileMetadataType }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"FATCAIDESSenderFileMetadata\")\r\n    public JAXBElement<FATCAIDESSenderFileMetadataType> createFATCAIDESSenderFileMetadata(FATCAIDESSenderFileMetadataType value) {\r\n        return new JAXBElement<FATCAIDESSenderFileMetadataType>(_FATCAIDESSenderFileMetadata_QNAME, FATCAIDESSenderFileMetadataType.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"SenderContactEmailAddressTxt\")\r\n    public JAXBElement<String> createSenderContactEmailAddressTxt(String value) {\r\n        return new JAXBElement<String>(_SenderContactEmailAddressTxt_QNAME, String.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"FATCAEntitySenderId\")\r\n    public JAXBElement<String> createFATCAEntitySenderId(String value) {\r\n        return new JAXBElement<String>(_FATCAEntitySenderId_QNAME, String.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"FATCAEntityReceiverId\")\r\n    public JAXBElement<String> createFATCAEntityReceiverId(String value) {\r\n        return new JAXBElement<String>(_FATCAEntityReceiverId_QNAME, String.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"OriginalIDESTransmissionId\")\r\n    public JAXBElement<String> createOriginalIDESTransmissionId(String value) {\r\n        return new JAXBElement<String>(_OriginalIDESTransmissionId_QNAME, String.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"FileCreateTs\")\r\n    public JAXBElement<String> createFileCreateTs(String value) {\r\n        return new JAXBElement<String>(_FileCreateTs_QNAME, String.class, null, value);\r\n    }\r\n\r\n}\r\n\r\n4. Add code for package-info.java\r\n```\r\n//\r\n// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 \r\n// See <a href=\"http://java.sun.com/xml/jaxb\">http://java.sun.com/xml/jaxb</a> \r\n// Any modifications to this file will be lost upon recompilation of the source schema. \r\n// Generated on: 2014.11.05 at 11:20:51 AM EST \r\n//\r\n\r\n@javax.xml.bind.annotation.XmlSchema(namespace = \"urn:fatca:idessenderfilemetadata\", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)\r\npackage fatca.idessenderfilemetadata;\r\n\r\n```\r\n\r\n##Keystore\r\nPlace the Keystore folder from the repository .zip file into the IDESDataPreparation folder. This will contain the test keys that the program will use. \r\n\r\n![Image 7](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image7.png)  \r\nFigure 7  \r\n\r\n##lib folder\r\nPlace the lib folder from the repository .zip file into the IDESDataPreparation folder. This will contain the .jar file for the console logging functionality.\r\n\r\n![Image 8](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image8.png)  \r\nFigure 8  \r\n\r\n\r\n##src folder\r\nAdd the src folder from the .zip repository or replicate the folder structure below. \r\n![Image 9](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image9.png)  \r\nFigure 9\r\n\r\n1. Add code for FATCAPackager.java\r\n\r\n```\r\npackage fatca;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.BufferedOutputStream;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.FileWriter;\r\nimport java.net.URI;\r\nimport java.nio.file.FileSystem;\r\nimport java.nio.file.FileSystems;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.StandardCopyOption;\r\nimport java.security.PrivateKey;\r\nimport java.security.PublicKey;\r\nimport java.security.cert.Certificate;\r\nimport java.security.cert.X509Certificate;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Date;\r\nimport java.util.Enumeration;\r\nimport java.util.GregorianCalendar;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.zip.Deflater;\r\nimport java.util.zip.ZipEntry;\r\nimport java.util.zip.ZipFile;\r\nimport java.util.zip.ZipOutputStream;\r\n\r\nimport javax.crypto.Cipher;\r\nimport javax.crypto.KeyGenerator;\r\nimport javax.crypto.SecretKey;\r\nimport javax.xml.bind.JAXBContext;\r\nimport javax.xml.bind.JAXBElement;\r\nimport javax.xml.bind.Marshaller;\r\nimport javax.xml.bind.Unmarshaller;\r\nimport javax.xml.datatype.DatatypeConstants;\r\nimport javax.xml.datatype.XMLGregorianCalendar;\r\n\r\nimport org.apache.log4j.Logger;\r\n\r\nimport com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;\r\n\r\nimport fatca.idessenderfilemetadata.FATCAEntCommunicationTypeCdType;\r\nimport fatca.idessenderfilemetadata.FATCAIDESSenderFileMetadataType;\r\n\r\npublic class FATCAPackager {\r\n\tpublic static String AES_TRANSFORMATION = \"AES/ECB/PKCS5Padding\";\r\n\tpublic static String RSA_TRANSFORMATION = \"RSA\";\r\n\tpublic static String SECRET_KEY_ALGO = \"AES\";\r\n\tpublic static int SECRET_KEY_SIZE = 256;\r\n\r\n\tpublic static String metadataEmailAddress=\"none@email.com\";\r\n\tpublic static int bufSize = 64 * 1024;\r\n\r\n\tpublic static boolean isCanonicalization = true;\r\n\t\r\n\tprotected static Logger logger = Logger.getLogger(new Object(){}.getClass().getEnclosingClass().getName());\r\n\r\n\tprotected FATCAXmlSigner signer = new FATCAXmlSigner();\r\n\tprotected Long fileId = 0L;\r\n\tprotected fatca.idessenderfilemetadata.ObjectFactory objFMetadata = new fatca.idessenderfilemetadata.ObjectFactory();\r\n\tprotected SimpleDateFormat sdfFileName = new SimpleDateFormat(\"yyyyMMdd'T'HHmmssSSS'Z'\");\r\n\tprotected SimpleDateFormat sdfFileCreateTs = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\r\n\t\r\n\tprotected int maxAttempts = 5;\r\n\t\r\n\tprotected boolean aes(int opmode, String inputFile, String outputFile, SecretKey secretKey) throws Exception {\r\n\t\tlogger.debug(\"--> aes(). opmode=\" + (opmode==Cipher.ENCRYPT_MODE?\"ENCRYPT\":\"DECRYPT\") + \r\n\t\t\t\", inputFile=\" + inputFile + \", outputFile=\" + outputFile);\r\n\t\tif (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE)\r\n\t\t\tthrow new Exception(\"Invalid opmode \" + opmode + \". Allowed opmodes are Cipher.ENCRYPT_MODE or Cipher.DECRYPT_MODE\");\r\n\t\tboolean ret = false;\r\n\t\tBufferedInputStream bis = null;\r\n\t\tBufferedOutputStream bos = null;\r\n\t\tint len;\r\n\t\tbyte[] output = null;\r\n\t\tbyte[] buf = new byte[bufSize];\r\n\t\tCipher cipher;\r\n\t\ttry {\r\n\t\t\tcipher = Cipher.getInstance(AES_TRANSFORMATION);\r\n\t\t\tcipher.init(opmode, secretKey);\r\n\t\t\tbis = new BufferedInputStream(new FileInputStream(inputFile));\r\n\t\t\tbos = new BufferedOutputStream(new FileOutputStream(outputFile));\r\n\t\t\twhile((len = bis.read(buf)) != -1) {\r\n\t\t\t\t//output = cipher.update(Arrays.copyOf(buf, len));\r\n\t\t\t\toutput = cipher.update(buf, 0, len);\r\n\t\t\t\tif (output.length > 0)\r\n\t\t\t\t\tbos.write(output);\r\n\t\t\t}\r\n\t\t\toutput = cipher.doFinal();\r\n\t\t\tif (output.length > 0)\r\n\t\t\t\tbos.write(output);\r\n\t\t\tbos.close(); bos = null;\r\n\t\t\tbis.close(); bis = null; \r\n\t\t\tret = true;\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\tif (bis != null) try{bis.close();}catch(Exception e) {}\r\n\t\t\tif (bos != null) try{bos.close();}catch(Exception e) {}\r\n\t\t}\r\n\t\tlogger.debug(\"<-- aes()\");\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tprotected boolean encrypt(String zippedSignedPlainTextFile, String cipherTextOutFile, Certificate[] receiversPublicCert,\r\n\t\t\tString[] encryptedAESKeyOutFiles) throws Exception {\r\n\t\tlogger.debug(\"--> encrypt(). zippedSignedPlainTextFile=\" + zippedSignedPlainTextFile + \", cipherTextOutFile=\" + cipherTextOutFile);\r\n\t\tPublicKey[] pubkeys = new PublicKey[receiversPublicCert.length];\r\n\t\tfor (int i = 0; i < receiversPublicCert.length; i++)\r\n\t\t\tpubkeys[i] = receiversPublicCert[i].getPublicKey();\r\n\t\tboolean flag = encrypt(zippedSignedPlainTextFile, cipherTextOutFile, pubkeys, encryptedAESKeyOutFiles);\r\n\t\tlogger.debug(\"<-- encrypt()\");\r\n\t\treturn flag;\r\n\t}\r\n\t\r\n\tprotected boolean encrypt(String zippedSignedPlainTextFile, String cipherTextOutFile, PublicKey[] receiversPublicKey,\r\n\t\t\tString[] encryptedAESKeyOutFiles) throws Exception {\r\n\t\tlogger.debug(\"--> encrypt(). zippedSignedPlainTextFile=\" + zippedSignedPlainTextFile + \", cipherTextOutFile\" + cipherTextOutFile);\r\n\t\tboolean ret = false;\r\n\t\tSecretKey skey = null;\r\n\t\tKeyGenerator generator;\r\n\t\tbyte[] encryptedAESKeyBuf;\r\n\t\tBufferedOutputStream bos = null;\r\n\t\tCipher cipher = null;\r\n\t\ttry {\r\n\t\t\tgenerator = KeyGenerator.getInstance(SECRET_KEY_ALGO);\r\n\t\t\tgenerator.init(SECRET_KEY_SIZE);\r\n\t\t\tskey = generator.generateKey();\r\n\t\t\tret = aes(Cipher.ENCRYPT_MODE, zippedSignedPlainTextFile, cipherTextOutFile, skey);\r\n\t\t\tif (ret) {\r\n\t\t\t\tfor (int i = 0; i < receiversPublicKey.length && i < encryptedAESKeyOutFiles.length; i++) {\r\n\t\t\t\t\tif (cipher == null)\r\n\t\t\t\t\t\tcipher = Cipher.getInstance(RSA_TRANSFORMATION);\r\n\t\t\t\t\tcipher.init(Cipher.WRAP_MODE, receiversPublicKey[i]);\r\n\t\t\t\t\tencryptedAESKeyBuf = cipher.wrap(skey);\r\n\t\t\t\t\tbos = new BufferedOutputStream(new FileOutputStream(encryptedAESKeyOutFiles[i]));\r\n\t\t\t\t\tbos.write(encryptedAESKeyBuf);\r\n\t\t\t\t\tbos.close(); bos = null;\r\n\t\t\t\t}\r\n\t\t\t\tret = true;\r\n\t\t\t}\r\n\t\t} catch(Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\tif (bos != null) try{bos.close();}catch(Exception e) {}\r\n\t\t}\r\n\t\tlogger.debug(\"<-- encrypt)\");\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tprotected boolean renameZipEntry(String zipFile, String entryName, String newEntryName) throws Exception {\r\n\t\tlogger.debug(\"--> renameZipEntry(). zipFile=\" + zipFile + \", entryName=\" + entryName + \", newEntryName=\" + newEntryName);\r\n\t\tboolean ret = false;\r\n        Map<String, String> props = new HashMap<String, String>(); \r\n        props.put(\"create\", \"false\"); \r\n        try {\r\n            URI zipDisk = URI.create(\"jar:\" + new File(zipFile).toURI());\r\n            FileSystem zipfs = FileSystems.newFileSystem(zipDisk, props);\r\n            Path pathInZipfile = zipfs.getPath(entryName);\r\n            Path renamedZipEntry = zipfs.getPath(newEntryName);\r\n            Files.move(pathInZipfile,renamedZipEntry, StandardCopyOption.ATOMIC_MOVE);\r\n            zipfs.close();\r\n            ret = true;\r\n        } catch(Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n        }\r\n\t\tlogger.debug(\"<-- renameZipEntry()\");\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tprotected boolean renameZipEntries(String zipFile, String[] entryNames, String[] newEntryNames) throws Exception {\r\n\t\tif (logger.isDebugEnabled()) {\r\n\t\t\tStringBuilder sb = new StringBuilder(\"--> renameZipEntries()\");\r\n\t\t\tsb.append(\", zipFile=\");\r\n\t\t\tsb.append(zipFile);\r\n\t\t\tsb.append(\", entryNames=[\");\r\n\t\t\tfor (int i = 0; i < entryNames.length; i++) {\r\n\t\t\t\tif (i > 0) sb.append(\",\");\r\n\t\t\t\tsb.append(entryNames[i]);\r\n\t\t\t}\r\n\t\t\tsb.append(\"], newEntryNames=[\");\r\n\t\t\tfor (int i = 0; i < newEntryNames.length; i++) {\r\n\t\t\t\tif (i > 0) sb.append(\",\");\r\n\t\t\t\tsb.append(newEntryNames[i]);\r\n\t\t\t}\r\n\t\t\tsb.append(\"]\");\r\n\t\t\tlogger.debug(sb.toString());\r\n\t\t}\r\n\t\tboolean ret = false;\r\n\t\tif (entryNames.length != newEntryNames.length)\r\n\t\t\tthrow new Exception(\"renameZipEntries entryNames and newEntryNames length should be same\");\r\n        Map<String, String> props = new HashMap<String, String>(); \r\n        props.put(\"create\", \"false\"); \r\n        try {\r\n            URI zipDisk = URI.create(\"jar:\" + new File(zipFile).toURI());\r\n        \tFileSystem zipfs = FileSystems.newFileSystem(zipDisk, props);\r\n        \tPath pathInZipfile, renamedZipEntry;\r\n        \tfor (int i = 0; i < entryNames.length; i++) {\r\n                pathInZipfile = zipfs.getPath(entryNames[i]);\r\n                renamedZipEntry = zipfs.getPath(newEntryNames[i]);\r\n                Files.move(pathInZipfile,renamedZipEntry, StandardCopyOption.ATOMIC_MOVE);\r\n        \t}\r\n            zipfs.close();\r\n            ret = true;\r\n        } catch(Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n        }\r\n\t\tlogger.debug(\"<-- renameZipEntries()\");\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tprotected boolean createZipFile(String[] inFiles, String outFile) throws Exception {\r\n\t\tif (logger.isDebugEnabled()) {\r\n\t\t\tStringBuilder sb = new StringBuilder(\"--> createZipFile()\");\r\n\t\t\tsb.append(\", inFiles=[\");\r\n\t\t\tfor (int i = 0; i < inFiles.length; i++) {\r\n\t\t\t\tif (i > 0) sb.append(\",\");\r\n\t\t\t\tsb.append(inFiles[i]);\r\n\t\t\t}\r\n\t\t\tsb.append(\"], outFile=\");\r\n\t\t\tsb.append(outFile);\r\n\t\t\tlogger.debug(sb.toString());\r\n\t\t}\r\n\t\tBufferedInputStream bis = null;\r\n\t\tZipOutputStream zos = null;\r\n\t\tZipEntry zipEntry;\r\n\t\tint len;\r\n\t\tboolean ret = false;\r\n\t\tString infile;\r\n\t\tbyte[] buf = new byte[bufSize];\r\n\t\ttry {\r\n\t\t\tzos = new ZipOutputStream(new FileOutputStream(outFile));\r\n\t\t\tzos.setLevel(Deflater.BEST_COMPRESSION);\r\n\t\t\tfor (int i = 0; i < inFiles.length; i++) {\r\n\t\t\t\t// drop folder names\r\n\t\t\t\tinfile = inFiles[i];\r\n\t\t\t\tlen = infile.lastIndexOf(\"/\");\r\n\t\t\t\tif (len == -1)\r\n\t\t\t\t\tlen = infile.lastIndexOf(\"\\\\\");\r\n\t\t\t\tif (len != -1)\r\n\t\t\t\t\tinfile = infile.substring(len+1);\r\n\t\t\t\tzipEntry = new ZipEntry(infile);\r\n\t\t\t\tzos.putNextEntry(zipEntry);\r\n\t\t\t\tbis = new BufferedInputStream(new FileInputStream(inFiles[i]));\r\n\t\t\t\twhile((len = bis.read(buf)) != -1)\r\n\t\t\t\t\tzos.write(buf, 0, len);\r\n\t\t\t\tbis.close(); bis = null;\r\n\t\t\t\tzos.closeEntry();\r\n\t\t\t}\r\n\t\t\tzos.close(); zos = null;\r\n\t\t\tret = true;\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\tif (bis != null) try{bis.close();}catch(Exception e) {}\r\n\t\t\tif (zos != null) try{zos.close();}catch(Exception e) {}\r\n\t\t}\r\n\t\tlogger.debug(\"<-- createZipFile()\");\r\n    \treturn ret;\r\n\t}\r\n\r\n\tprotected ArrayList<String> unzipFile(String inFile) throws Exception {\r\n\t\treturn unzipFile(inFile, null);\r\n\t}\r\n\t\r\n\tprotected ArrayList<String> unzipFile(String inFile, String extractFolder) throws Exception {\r\n\t\tlogger.debug(\"--> unzipFile(). inFile=\" + inFile + \", extractFolder=\" + extractFolder);\r\n    \tBufferedInputStream bis = null;\r\n    \tBufferedOutputStream bos = null;\r\n    \tint len;\r\n    \tZipFile zipFile = null;\r\n    \tEnumeration<? extends ZipEntry> entries;\r\n    \tZipEntry entry;\r\n    \tArrayList<String> entryList = null;\r\n    \tbyte[] buf = new byte[bufSize];\r\n    \tString outFile;\r\n\t\ttry {\r\n\t\t\tif (extractFolder == null)\r\n\t\t\t\textractFolder = \".\";\r\n\t\t\tif (!extractFolder.endsWith(\"/\") && !extractFolder.endsWith(\"\\\\\"))\r\n\t\t\t\textractFolder += \"/\";\r\n\t\t\tzipFile = new ZipFile(inFile);\r\n\t    \tentries = zipFile.entries();\r\n\t    \twhile (entries.hasMoreElements()) {\r\n\t    \t\tif (entryList == null)\r\n\t\t    \t\tentryList = new ArrayList<String>();\r\n\t    \t\tentry = entries.nextElement();\r\n\t    \t\toutFile = extractFolder + entry.getName();\r\n\t    \t\tentryList.add(outFile);\r\n\t    \t\tbis = new BufferedInputStream(zipFile.getInputStream(entry));\r\n\t    \t\tbos = new BufferedOutputStream(new FileOutputStream(outFile));\r\n\t    \t\twhile((len = bis.read(buf)) != -1)\r\n\t    \t\t\tbos.write(buf, 0, len);\r\n\t    \t\tbos.close(); bos = null;\r\n\t    \t\tbis.close(); bis = null;\r\n\t    \t}\r\n\t    \tzipFile.close(); zipFile = null;\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\tif (bis != null) try{bis.close();}catch(Exception e) {}\r\n\t\t\tif (bos != null) try{bos.close();}catch(Exception e) {}\r\n\t\t\tif (zipFile != null) try{zipFile.close();}catch(Exception e) {}\r\n\t\t}\r\n\t\tlogger.debug(\"<-- unzipFile()\");\r\n\t\treturn entryList;\r\n\t}\r\n\r\n\t//_Payload.xml,_Metadata.xml, _Payload.zip, _Key, _Payload\r\n\tprotected String getFileName(String senderGiin, String filename) throws Exception {\r\n\t\tsynchronized (fileId) {\r\n\t\t\tlogger.debug(\"--> getFileName(). senderGiin=\" + senderGiin + \", filename=\" + filename);\r\n\t\t\tif (fileId == Long.MAX_VALUE) fileId = 0L;\r\n\t\t\tString xmlfilename = senderGiin + \"_\" + fileId++ + filename;\r\n\t\t\tFile file = new File(xmlfilename);\r\n\t\t\tint attempts = maxAttempts;\r\n\t\t\twhile(!file.createNewFile() && attempts-- > 0) {\r\n\t\t\t\txmlfilename = senderGiin + \"_\" + fileId++ + filename;\r\n\t\t\t\tfile = new File(xmlfilename);\r\n\t\t\t}\r\n\t\t\tif (attempts <= 0)\r\n\t\t\t\tthrow new Exception (\"Unable to getFileName() - file=\" + file.getAbsolutePath());\r\n\t\t\tlogger.debug(\"<-- getFileName()\");\r\n\t\t\treturn xmlfilename;\r\n\t\t}\r\n\t}\r\n\t\r\n\tprotected String getIDESFileName(String senderGiin) throws Exception {\r\n\t\tsynchronized (fileId) {\r\n\t\t\tlogger.debug(\"--> getIDESFileName(). senderGiin=\" + senderGiin);\r\n\t\t\tDate date = new Date();\r\n\t\t\tString outfile = sdfFileName.format(date) + \"_\" + senderGiin + \".zip\";\r\n\t\t\tFile file = new File(outfile);\r\n\t\t\tint attempts = maxAttempts;\r\n\t\t\twhile (!file.createNewFile() && attempts-- > 0) {\r\n\t\t\t\toutfile = sdfFileName.format(new Date()) + \"_\" + senderGiin + \".zip\";\r\n\t\t\t\tfile = new File(outfile);\r\n\t\t\t}\r\n\t\t\tif (attempts <= 0)\r\n\t\t\t\tthrow new Exception (\"Unable to getFileName() - file=\" + file.getAbsolutePath());\r\n\t\t\tlogger.debug(\"<-- getIDESFileName()\");\r\n\t\t\treturn outfile;\r\n\t\t}\r\n\t}\r\n\t\r\n\tprotected XMLGregorianCalendar genTaxYear(int year) {\r\n\t\tXMLGregorianCalendar taxyear = new XMLGregorianCalendarImpl(new GregorianCalendar());\r\n\t\ttaxyear.setTimezone(DatatypeConstants.FIELD_UNDEFINED);\r\n\t\ttaxyear.setTime(DatatypeConstants.FIELD_UNDEFINED, DatatypeConstants.FIELD_UNDEFINED, DatatypeConstants.FIELD_UNDEFINED);\r\n\t\ttaxyear.setDay(DatatypeConstants.FIELD_UNDEFINED);\r\n\t\ttaxyear.setMonth(DatatypeConstants.FIELD_UNDEFINED);\r\n\t\ttaxyear.setYear(year);\r\n\t\treturn taxyear;\r\n\t}\r\n\t\r\n\tprotected String getFileName(String filename) {\r\n\t\tFile f = new File(filename);\r\n\t\treturn f.getName();\r\n\t}\r\n\t\r\n\tpublic String signAndCreatePkg(String unsignedXml, PrivateKey senderPrivateKey, X509Certificate senderPublicCert,\r\n\t\t\tString senderGiin, String receiverGiin, X509Certificate receiverPublicCert, int taxyear) throws Exception {\r\n\t\tlogger.debug(\"--> signAndCreatePkg(). unsignedXml=\" + unsignedXml + \", senderGiin=\" + senderGiin +\r\n\t\t\t\t\", receiverGiin=\" + receiverGiin + \", taxyear=\" + taxyear);\r\n\t\tString signedxml = unsignedXml + \".signed\";\r\n\t\tboolean success = false;\r\n\t\tString ret = null;\r\n\t\tif (isCanonicalization)\r\n\t\t\tsuccess = signer.signStreamingWithCanonicalization(unsignedXml, signedxml, senderPrivateKey, senderPublicCert);\r\n\t\telse\r\n\t\t\tsuccess = signer.signStreaming(unsignedXml, signedxml, senderPrivateKey, senderPublicCert);\r\n\t\tif (success)\r\n\t\t\tret = createPkgWithApprover(signedxml, senderGiin, receiverGiin, receiverPublicCert, null, null, taxyear);\r\n\t\tlogger.debug(\"<-- signAndCreatePkg()\");\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tpublic String signAndCreatePkgWithApprover(String unsignedxml, PrivateKey senderPrivateKey, X509Certificate senderPublicCert,\r\n\t\t\tString senderGiin, String receiverGiin, X509Certificate receiverPublicCert, String approverGiin, \r\n\t\t\tX509Certificate approvercert, int taxyear) throws Exception {\r\n\t\tlogger.debug(\"--> signAndCreatePkgWithApprover(). xmlfilename=\" + unsignedxml + \", senderGiin=\" + senderGiin +\r\n\t\t\t\t\", receiverGiin=\" + receiverGiin + \", approverGiin=\" + approverGiin + \", taxyear=\" + taxyear);\r\n\t\tString signedxml = unsignedxml + \".signed\";\r\n\t\tboolean success = false;\r\n\t\tString ret = null;\r\n\t\tif (isCanonicalization)\r\n\t\t\tsuccess = signer.signStreamingWithCanonicalization(unsignedxml, signedxml, senderPrivateKey, senderPublicCert);\r\n\t\telse\r\n\t\t\tsuccess = signer.signStreaming(unsignedxml, signedxml, senderPrivateKey, senderPublicCert);\r\n\t\tif (success)\r\n\t\t\tret = createPkgWithApprover(signedxml, senderGiin, receiverGiin, receiverPublicCert, approverGiin, approvercert, taxyear);\r\n\t\tlogger.debug(\"<-- signAndCreatePkgWithApprover()\");\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tpublic String createPkg(String signedXmlFile, String senderGiin, String receiverGiin,  \r\n\t\t\tX509Certificate receiverPublicCert, int taxyear) throws Exception {\r\n\t\treturn createPkgWithApprover(signedXmlFile, senderGiin, receiverGiin, receiverPublicCert, null, null, taxyear);\r\n\t}\r\n\t\r\n\tpublic String createPkgWithApprover(String signedXmlFile, String senderGiin, String receiverGiin,  \r\n\t\t\tX509Certificate receiverPublicCert, String approverGiin, \r\n\t\t\tX509Certificate approvercert, int taxyear) throws Exception {\r\n\t\tlogger.debug(\"--> createPkgWithApprover(). signedXmlFile= \" + signedXmlFile + \", senderGiin=\" + senderGiin + \r\n\t\t\t\t\", receiverGiin=\" + receiverGiin + \", approverGiin=\" + approverGiin);\r\n\t\tString idesOutFile = null;\r\n\t\ttry {\r\n\t\t\tDate date = new Date();\r\n\t\t\tString metadatafile = getFileName(senderGiin, \"_Metadata.xml\");\r\n\t\t\tJAXBContext jaxbCtxMetadata = JAXBContext.newInstance(FATCAIDESSenderFileMetadataType.class);            \r\n\t\t\tMarshaller mrshler = jaxbCtxMetadata.createMarshaller();\r\n\t\t\tmrshler.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\r\n\t\t\t\r\n\t\t\tFATCAIDESSenderFileMetadataType metadata = objFMetadata.createFATCAIDESSenderFileMetadataType();\r\n\t\t\tJAXBElement<FATCAIDESSenderFileMetadataType> jaxbElemMetadata = objFMetadata.createFATCAIDESSenderFileMetadata(metadata);\r\n\t\t\t\r\n\t\t\tmetadata.setFATCAEntCommunicationTypeCd(FATCAEntCommunicationTypeCdType.RPT);\r\n\t\t\tmetadata.setFATCAEntitySenderId(senderGiin);\r\n\t\t\tmetadata.setFileRevisionInd(false);\r\n\t\t\tString senderFileId = getIDESFileName(senderGiin);\r\n\t\t\tFile file = new File(senderFileId);\r\n\t\t\tmetadata.setSenderFileId(file.getName());\r\n\t\t\tmetadata.setTaxYear(genTaxYear(taxyear));\r\n\t\t\tmetadata.setFATCAEntityReceiverId(receiverGiin);\r\n\t\t\tmetadata.setFileCreateTs(sdfFileCreateTs.format(date));\r\n\t\t\tmetadata.setSenderContactEmailAddressTxt(metadataEmailAddress);\r\n\t\t\tFileWriter fw = new FileWriter(metadatafile);\r\n\t\t\tmrshler.marshal(jaxbElemMetadata, fw);\r\n\t\t\tfw.close();\r\n\t\t\tString xmlzipFilename;\r\n\t\t\tboolean success = false;\r\n\t\t\txmlzipFilename = getFileName(senderGiin, \"_Payload.zip\");\r\n\t\t\tsuccess = createZipFile(new String[]{signedXmlFile}, xmlzipFilename);\r\n\t\t\tif (success)\r\n\t\t\t\tsuccess = renameZipEntry(xmlzipFilename, getFileName(signedXmlFile), senderGiin + \"_Payload.xml\");\r\n\t\t\tif (!success)\r\n\t\t\t\tthrow new Exception(\"uanble to create \" + xmlzipFilename);\r\n\t\t\tidesOutFile = senderFileId;\r\n\t\t\tCertificate[] certs = null;\r\n\t\t\tString[] encryptedAESKeyOutFiles = null;\r\n\t\t\tif (approvercert != null && approverGiin != null) {\r\n\t\t\t\tcerts = new X509Certificate[] {receiverPublicCert, approvercert};\r\n\t\t\t\tencryptedAESKeyOutFiles = new String[]{getFileName(receiverGiin, \"_Key\"), getFileName(approverGiin, \"_Key\")};\r\n\t\t\t} else if (receiverPublicCert != null){\r\n\t\t\t\tcerts = new X509Certificate[] {receiverPublicCert};\r\n\t\t\t\tencryptedAESKeyOutFiles = new String[]{getFileName(receiverGiin, \"_Key\")};\r\n\t\t\t} else\r\n\t\t\t\tthrow new Exception (\"both approvingEntityCert and receivingEntityCert is null\");\r\n\t\t\tString xmlZippedEncryptedFile = getFileName(senderGiin, \"_Payload\");\r\n\t\t\tsuccess = encrypt(xmlzipFilename, xmlZippedEncryptedFile, certs, encryptedAESKeyOutFiles);\r\n\t\t\tif (! success)\r\n\t\t\t\tthrow new Exception(\"encryption failed. xmlzipFilename=\" + xmlzipFilename);\r\n\t\t\tint count = 0;\r\n\t\t\tString[] infiles = new String[encryptedAESKeyOutFiles.length + 2];\r\n\t\t\tfor (count = 0; count < encryptedAESKeyOutFiles.length; count++)\r\n\t\t\t\tinfiles[count] = encryptedAESKeyOutFiles[count];\r\n\t\t\tinfiles[count++] =  xmlZippedEncryptedFile;\r\n\t\t\tinfiles[count] = metadatafile;\r\n\t\t\tsuccess = createZipFile(infiles, idesOutFile);\r\n\t\t\tif (success) {\r\n\t\t\t\tif (encryptedAESKeyOutFiles.length == 2)\r\n\t\t\t\t\tsuccess = renameZipEntries(idesOutFile, new String[]{getFileName(xmlZippedEncryptedFile), getFileName(metadatafile), \r\n\t\t\t\t\t\t\tgetFileName(encryptedAESKeyOutFiles[0]), getFileName(encryptedAESKeyOutFiles[1])},\r\n\t\t\t\t\t\t\tnew String[]{senderGiin + \"_Payload\", senderGiin + \"_Metadata.xml\", \r\n\t\t\t\t\t\t\treceiverGiin + \"_Key\", approverGiin + \"_Key\"});\r\n\t\t\t\telse\r\n\t\t\t\t\tsuccess = renameZipEntries(idesOutFile, new String[]{getFileName(xmlZippedEncryptedFile), getFileName(metadatafile), \r\n\t\t\t\t\t\tgetFileName(encryptedAESKeyOutFiles[0])},\r\n\t\t\t\t\t\tnew String[]{senderGiin + \"_Payload\", senderGiin + \"_Metadata.xml\", \r\n\t\t\t\t\t\treceiverGiin + \"_Key\"});\r\n\t\t\t}\r\n\t\t\tif (!success)\r\n\t\t\t\tthrow new Exception(\"unable to create zip file \" + idesOutFile);\r\n\t\t\tfor (int i = 0; i < infiles.length; i++)\r\n\t\t\t\tdeleteFile(infiles[i]);\r\n\t\t\tdeleteFile(xmlzipFilename);\r\n\t\t\t//deleteFile(signedXmlFile);\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t\tlogger.debug(\"<-- createPkgWithApprover()\");\r\n\t\treturn idesOutFile;\r\n\t}\r\n\r\n\tprotected boolean decrypt(String cipherTextFile, String encryptedAESKeyFile, String zippedSignedPlainTextFile, PrivateKey privkey) throws Exception {\r\n\t\tlogger.debug(\"--> decrypt(). cipherTextFile= \" + cipherTextFile + \", encryptedAESKeyFile=\" + encryptedAESKeyFile + \r\n\t\t\t\t\", zippedSignedPlainTextFile=\" + zippedSignedPlainTextFile);\r\n\t\tSecretKey skey;\r\n\t\tboolean ret = false;\r\n\t\tBufferedInputStream bis = null;\r\n\t\tbyte[] buf, skeyBuf = null;\r\n\t\tint len, count;\r\n\t\ttry {\r\n\t\t\tbuf = new byte[bufSize];\r\n\t\t\tbis = new BufferedInputStream(new FileInputStream(encryptedAESKeyFile));\r\n\t\t\twhile((len = bis.read(buf)) != -1) {\r\n\t\t\t\tif (skeyBuf == null) {\r\n\t\t\t\t\tskeyBuf = new byte[len];\r\n\t\t\t\t\tSystem.arraycopy(buf, 0, skeyBuf, 0, len);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcount = skeyBuf.length;\r\n\t\t\t\t\tskeyBuf = Arrays.copyOf(skeyBuf, skeyBuf.length + len);\r\n\t\t\t\t\tSystem.arraycopy(buf, 0, skeyBuf, count, len);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbis.close(); bis = null;\r\n\t\t\tCipher cipher = Cipher.getInstance(RSA_TRANSFORMATION);\r\n\t\t\tcipher.init(Cipher.UNWRAP_MODE, privkey);\r\n\t\t\tskey = (SecretKey)cipher.unwrap(skeyBuf, SECRET_KEY_ALGO, Cipher.SECRET_KEY);\r\n\t\t\tret = aes(Cipher.DECRYPT_MODE, cipherTextFile, zippedSignedPlainTextFile, skey);\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\tif (bis != null) try{bis.close();}catch(Exception e) {}\r\n\t\t}\r\n\t\tlogger.debug(\"<-- createPkgWithApprover()\");\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tprotected void deleteFile(String filename) {\r\n\t\tFile file = new File(filename);\r\n\t\tint attempts = maxAttempts;\r\n\t\twhile (file.exists() && !file.delete() && attempts-->0)\r\n\t\t\tThread.yield();\r\n\t}\r\n\r\n\tpublic boolean unpack(String idesPkgFile, String keystoreType, String keystoreFile, String keystorePwd, String keyPwd, String keyAlias) throws Exception {\r\n\t\tlogger.debug(\"--> unpack(). idesPkgFile=\" + idesPkgFile + \", keystoreType=\" + keystoreType + \r\n\t\t\t\t\", keystoreFile=\" + keystoreFile + \", keyAlias=\" + keyAlias);\r\n\t\tPrivateKey privateKey = UtilShared.getPrivateKey(keystoreType, keystoreFile, keystorePwd, keyPwd, keyAlias);\r\n\t\tboolean flag = unpack (idesPkgFile, privateKey);\r\n\t\tlogger.debug(\"<-- unpack()\");\r\n\t\treturn flag;\r\n\t}\r\n\t\r\n\tpublic boolean unpack(String idesPkgFile, PrivateKey receiverPrivateKey) throws Exception {\r\n\t\tlogger.debug(\"--> unpack(). idesPkgFile=\" + idesPkgFile);\r\n\t\tboolean flag = unpack(idesPkgFile, receiverPrivateKey, false);\r\n\t\tlogger.debug(\"<-- unpack()\");\r\n\t\treturn flag;\r\n\t}\r\n\t\r\n\tpublic boolean unpackForApprover(String idesPkgFile, String approverKeystoreType, String approverKeystoreFile, \r\n\t\t\tString approverKeystorePwd, String approverKeyPwd, String approverKeyAlias) throws Exception {\r\n\t\tlogger.debug(\"--> unpackForApprover(). idesPkgFile=\" + idesPkgFile + \", approverKeystoreType=\" + approverKeystoreType + \r\n\t\t\t\t\", approverKeystoreFile=\" + approverKeystoreFile + \", approverKeyAlias=\" + approverKeyAlias);\r\n\t\tPrivateKey approverPrivateKey = UtilShared.getPrivateKey(approverKeystoreType, approverKeystoreFile, approverKeystorePwd, approverKeyPwd, approverKeyAlias);\r\n\t\tboolean flag = unpackForApprover(idesPkgFile, approverPrivateKey);\r\n\t\tlogger.debug(\"<-- unpackForApprover()\");\r\n\t\treturn flag;\r\n\t}\r\n\t\r\n\tpublic boolean unpackForApprover(String idesPkgFile, PrivateKey approverPrivateKey) throws Exception {\r\n\t\tlogger.debug(\"--> unpackForApprover(). idesPkgFile=\" + idesPkgFile);\r\n\t\tboolean flag = unpack(idesPkgFile, approverPrivateKey, true);\r\n\t\tlogger.debug(\"<-- unpackForApprover()\");\r\n\t\treturn flag;\r\n\t}\r\n\t\r\n\tprotected boolean unpack(String idesPkgFile, PrivateKey privateKey, boolean isApprover) throws Exception {\r\n\t\tlogger.debug(\"--> unpack(). idesPkg=\" + idesPkgFile + \", isApprover=\" + isApprover);\r\n\t\tboolean ret = false;\r\n\t\ttry {\r\n\t\t\tArrayList<String> entryList = unzipFile(idesPkgFile);\r\n\t\t\tString approverKeyFile = null, receiverKeyFile = null, payloadFile = null, metadataFile = null,  receiverGiin = null, filename;\r\n\t\t\t// get metadata file\r\n\t\t\tfor (int i = 0; i < entryList.size(); i++) {\r\n\t\t\t\tfilename = entryList.get(i);\r\n\t\t\t\tif (filename.contains(\"Metadata\"))\r\n\t\t\t\t\tmetadataFile = filename;\r\n\t\t\t\telse if (filename.contains(\"Payload\"))\r\n\t\t\t\t\tpayloadFile = filename;\r\n\t\t\t\telse if (filename.contains(\"Key\")) {\r\n\t\t\t\t\tif (receiverKeyFile == null)\r\n\t\t\t\t\t\treceiverKeyFile = filename;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tapproverKeyFile = filename;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (metadataFile == null)\r\n\t\t\t\tthrow new Exception(\"Invalid package - no metadata file\");\r\n\t\t\tif (payloadFile == null)\r\n\t\t\t\tthrow new Exception(\"Invalid package - no payload file\");\r\n\r\n\t\t\tif (approverKeyFile != null) {\r\n\t\t\t\tJAXBContext jaxbCtxMetadata = JAXBContext.newInstance(\"fatca.idessenderfilemetadata\");\r\n\t\t\t\tUnmarshaller unmrshlr = jaxbCtxMetadata.createUnmarshaller();\r\n\t\t\t\tObject obj = unmrshlr.unmarshal(new File(metadataFile));;\r\n\t\t\t\tif (obj instanceof JAXBElement<?>) {\r\n\t\t\t\t\t@SuppressWarnings(\"unchecked\")\r\n\t\t\t\t\tJAXBElement<FATCAIDESSenderFileMetadataType> jaxbElem = \r\n\t\t\t\t\t\t(JAXBElement<FATCAIDESSenderFileMetadataType>)obj;\r\n\t\t\t\t\tFATCAIDESSenderFileMetadataType metadataObj = jaxbElem.getValue();\r\n\t\t\t\t\treceiverGiin = metadataObj.getFATCAEntityReceiverId();\r\n\t\t\t\t\tif (!receiverKeyFile.contains(receiverGiin)) {\r\n\t\t\t\t\t\tfilename = approverKeyFile;\r\n\t\t\t\t\t\tapproverKeyFile = receiverKeyFile;\r\n\t\t\t\t\t\treceiverKeyFile = filename;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (receiverKeyFile != null)\r\n\t\t\t\treceiverGiin = receiverKeyFile.substring(0, receiverKeyFile.length() - \"_Key\".length());\r\n\t\t\tif (receiverGiin == null)\r\n\t\t\t\tthrow new Exception(\"Invalid metadata file - missing receiver giin or corrupt zip file - no reveiverKeyFile\");\r\n\t\t\tif (isApprover && approverKeyFile == null)\r\n\t\t\t\tthrow new Exception(\"Invalid package - no approverKeyFile\");\r\n\t\t\tString zippedSignedPlainTextFile = getFileName(receiverGiin, \"_Payload.zip\");\r\n\t\t\tif (approverKeyFile != null && isApprover)\r\n\t\t\t\tret = decrypt(payloadFile, approverKeyFile, zippedSignedPlainTextFile, privateKey);\r\n\t\t\telse\r\n\t\t\t\tret = decrypt(payloadFile, receiverKeyFile, zippedSignedPlainTextFile, privateKey);\r\n\r\n\t\t\tif (ret) {\r\n\t\t\t\tif (unzipFile(zippedSignedPlainTextFile) == null)\r\n\t\t\t\t\tret = false;\r\n\t\t\t\telse\r\n\t\t\t\t\tdeleteFile(zippedSignedPlainTextFile);\r\n\t\t\t}\r\n\t\t\tdeleteFile(payloadFile);\r\n\t\t\t//deleteFile(metadataFile);\r\n\t\t\tdeleteFile(receiverKeyFile);\r\n\t\t\tif (approverKeyFile != null)\r\n\t\t\t\tdeleteFile(approverKeyFile);\r\n\t\t} catch(Exception e) {\r\n\t\t\tlogger.error(e.getMessage());\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t\tlogger.debug(\"<-- unpack()\");\r\n\t\treturn ret;\r\n\t}\r\n}\r\n```\r\n\r\n2. Add code for FATCAXmlSigner.java\r\n\r\n```\r\npackage fatca;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.BufferedOutputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\nimport java.security.PrivateKey;\r\nimport java.security.Signature;\r\nimport java.security.cert.X509Certificate;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Date;\r\nimport java.util.List;\r\n\r\nimport javax.xml.XMLConstants;\r\nimport javax.xml.crypto.XMLStructure;\r\nimport javax.xml.crypto.dom.DOMStructure;\r\nimport javax.xml.crypto.dsig.CanonicalizationMethod;\r\nimport javax.xml.crypto.dsig.DigestMethod;\r\nimport javax.xml.crypto.dsig.Reference;\r\nimport javax.xml.crypto.dsig.SignedInfo;\r\nimport javax.xml.crypto.dsig.XMLObject;\r\nimport javax.xml.crypto.dsig.XMLSignature;\r\nimport javax.xml.crypto.dsig.XMLSignatureFactory;\r\nimport javax.xml.crypto.dsig.dom.DOMSignContext;\r\nimport javax.xml.crypto.dsig.keyinfo.KeyInfo;\r\nimport javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;\r\nimport javax.xml.crypto.dsig.keyinfo.X509Data;\r\nimport javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;\r\nimport javax.xml.crypto.dsig.spec.TransformParameterSpec;\r\nimport javax.xml.parsers.DocumentBuilder;\r\nimport javax.xml.parsers.DocumentBuilderFactory;\r\nimport javax.xml.parsers.SAXParserFactory;\r\nimport javax.xml.transform.OutputKeys;\r\nimport javax.xml.transform.Transformer;\r\nimport javax.xml.transform.TransformerFactory;\r\nimport javax.xml.transform.dom.DOMSource;\r\nimport javax.xml.transform.stream.StreamResult;\r\n\r\nimport org.apache.log4j.Level;\r\nimport org.apache.log4j.Logger;\r\nimport org.w3c.dom.Document;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\n\r\nimport com.sun.org.apache.xml.internal.security.Init;\r\nimport com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;\r\nimport com.sun.org.apache.xml.internal.security.utils.Base64;\r\nimport com.sun.org.apache.xml.internal.security.utils.IgnoreAllErrorHandler;\r\n\r\npublic class FATCAXmlSigner {\r\n\tpublic static String SIGNATURE_OBJECT_ID = \"FATCA\";\r\n\tpublic static String SIGNATUER_ALGO = \"SHA256withRSA\";\r\n\tpublic static String MESSAGE_DIGEST_ALGO = \"SHA-256\";\r\n\tpublic static String SIGNATURE_DIGEST_METHOD = DigestMethod.SHA256;\r\n\tpublic static String SIGNATURE_METHOD = \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\";\r\n\tpublic static String CANONICALIZATION_METHOD = CanonicalizationMethod.INCLUSIVE;\r\n\t\r\n\tpublic static int bufSize = 64 * 1024;\r\n\r\n\tprotected static Logger logger = Logger.getLogger(new Object(){}.getClass().getEnclosingClass().getName());\r\n\tprotected static int logLevel = logger.getEffectiveLevel().toInt();\r\n\tprotected static String digprefix = \"<Object xmlns=\\\"http://www.w3.org/2000/09/xmldsig#\\\" Id=\\\"\" + SIGNATURE_OBJECT_ID + \"\\\">\";\r\n\tprotected static String digsuffix = \"</Object>\";\r\n\tprotected static final int STARTTAG = 0;\r\n\tprotected static final int ENDTAG = 1;\r\n\tprotected static final int CHUNK = 2;\r\n\t\r\n\t// for debug\r\n\tpublic StringBuilder digestBuf  = null;\r\n\r\n\tprotected XMLSignatureFactory xmlSigFactory = null;\r\n\tprotected KeyInfoFactory keyInfoFactory = null;\r\n\tprotected TransformerFactory transformerFactory = null;\r\n\tprotected SAXParserFactory saxFactory = null;  \r\n\tprotected Canonicalizer canonicalizer =  null;\r\n\tprotected DocumentBuilder docBuilder = null;\r\n        \r\n\tprotected String digestValue = null, signatureValue = null;\r\n\tprotected MessageDigest messageDigest = null;\r\n\tprotected ArrayList<String> nsStartTagList = new ArrayList<String>();\r\n\tprotected ArrayList<String> nsEndTagList = new ArrayList<String>();\r\n\r\n    public FATCAXmlSigner() {\r\n    \ttry {\r\n    \t\tInit.init();\r\n    \t\ttransformerFactory = TransformerFactory.newInstance();\r\n    \t\tsaxFactory = SAXParserFactory.newInstance();  \r\n    \t\txmlSigFactory = XMLSignatureFactory.getInstance();\r\n            keyInfoFactory = xmlSigFactory.getKeyInfoFactory();\r\n            saxFactory.setNamespaceAware(false);\r\n            canonicalizer = Canonicalizer.getInstance(CANONICALIZATION_METHOD);\r\n            DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();\r\n            dfactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE);\r\n            dfactory.setNamespaceAware(true);\r\n            dfactory.setValidating(true);\r\n            docBuilder = dfactory.newDocumentBuilder();\r\n            docBuilder.setErrorHandler(new IgnoreAllErrorHandler());\r\n    \t} catch(Exception e) {\r\n    \t\tlogger.error(e.getMessage(), e);\r\n    \t\tthrow new RuntimeException(e);\r\n    \t}\r\n    }\r\n    \r\n    protected void initMessageDigest() throws NoSuchAlgorithmException {\r\n\t\tlogger.debug(\"--> initMessageDigest()\");\r\n\t\tdigestValue = null;\r\n    \tmessageDigest = MessageDigest.getInstance(MESSAGE_DIGEST_ALGO);\r\n\t\tmessageDigest.update(digprefix.getBytes());\r\n\t\tif (logLevel <= Level.DEBUG_INT && digestBuf != null) {\r\n    \t\tdigestBuf.setLength(0);\r\n    \t\tdigestBuf.append(digprefix);\r\n    \t}\r\n\t\tlogger.debug(\"<-- initMessageDigest()\");\r\n    }\r\n    \r\n    protected void finalizeMessageDigest() {\r\n\t\tlogger.debug(\"--> finalizeMessageDigest()\");\r\n\t\tmessageDigest.update(digsuffix.getBytes());\r\n\t\tdigestValue = Base64.encode(messageDigest.digest());\r\n\t\tif (logLevel <= Level.DEBUG_INT && digestBuf != null)\r\n    \t\tdigestBuf.append(digsuffix);\r\n\t\tlogger.debug(\"<-- finalizeMessageDigest()\");\r\n    }\r\n\r\n\tprotected void calcMsgDigestByParsingDoc(String infile) throws Exception {\r\n\t\tthrow new Exception (\"not yet implemented\");\r\n\t}\r\n\t\r\n    protected void calcMsgDigestNoTransformation(String xmlInputFile) throws Exception {\r\n\t\tlogger.debug(\"--> calcMsgDigestNoTransformation(). xmlInputFile=\" + xmlInputFile);\r\n\t\tint len;\r\n\t\tString tmp;\r\n\t\tinitMessageDigest();\r\n    \tBufferedInputStream bis = new BufferedInputStream(new FileInputStream(xmlInputFile));\r\n\t\tboolean flag = true;\r\n\t\tbyte[] tmpBuf = new byte[bufSize];\r\n\t\twhile((len = bis.read(tmpBuf)) != -1) {\r\n\t\t\ttmp = new String(tmpBuf, 0, len);\r\n\t\t\ttmp = tmp.replace(\"\\r\", \"\");\r\n\t\t\tif (flag) {\r\n\t\t\t\tflag = false;\r\n\t\t\t\tif (tmp.startsWith(\"<?xml\")) {\r\n\t\t\t\t\tint pos = tmp.indexOf(\">\");\r\n\t\t\t\t\tif (pos != -1) {\r\n\t\t\t\t\t\ttmp = tmp.substring(pos+1);\r\n\t\t\t\t\t\tif (tmp.startsWith(\"\\n\"))\r\n\t\t\t\t\t\t\ttmp = tmp.substring(1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n    \t\tif (logLevel <= Level.DEBUG_INT && digestBuf != null)\r\n\t\t\t\tdigestBuf.append(tmp);\r\n\t\t\tmessageDigest.update(tmp.getBytes());\r\n\t\t}\r\n\t\tbis.close();\r\n\t\tfinalizeMessageDigest();\r\n\t\tlogger.debug(\"<-- calcMsgDigestNoTransformation()\");\r\n    }\r\n    \r\n    protected Document createSignedDoc(boolean isTransformed, PrivateKey signatureKey, X509Certificate signaturePublicCert) throws Exception {\r\n    \treturn createSignedDoc(null, isTransformed, signatureKey, signaturePublicCert);\r\n    }\r\n\r\n   protected Document createSignedDoc(String xmlInputFile, boolean isTransformed, PrivateKey signatureKey, X509Certificate signaturePublicCert) throws Exception {\r\n\t\tlogger.debug(\"--> createSignedDoc(). xmlInputFile=\" + xmlInputFile);\r\n    \tBufferedInputStream bis = null;\r\n        Document doc = null;\r\n    \ttry {\r\n            String uri = \"\";\r\n            Reference sigref;\r\n            Node node;\r\n        \tif (xmlInputFile != null) {\r\n            \tbis = new BufferedInputStream(new FileInputStream(xmlInputFile));\r\n    \t        doc = docBuilder.parse(bis);\r\n    \t        node = doc.getDocumentElement();\r\n        \t}\r\n        \telse {\r\n        \t\tdoc = docBuilder.newDocument();\r\n            \tnode = doc.createTextNode(\"text\");\r\n        \t}\r\n        \tXMLStructure content = new DOMStructure(node);\r\n            XMLObject xmlobj = xmlSigFactory.newXMLObject\r\n            \t(Collections.singletonList(content), SIGNATURE_OBJECT_ID, null, null);\r\n        \tList<XMLObject> xmlObjs = Collections.singletonList(xmlobj);\r\n        \tif (!\"\".equals(SIGNATURE_OBJECT_ID))\r\n        \t\turi = \"#\" + SIGNATURE_OBJECT_ID;\r\n\t        if (isTransformed)\r\n\t        \tsigref = xmlSigFactory.newReference(uri, xmlSigFactory.newDigestMethod(SIGNATURE_DIGEST_METHOD, null), \r\n\t        \t\t\tCollections.singletonList(xmlSigFactory.newTransform(CANONICALIZATION_METHOD, \r\n\t        \t\t\t\t\t(TransformParameterSpec) null)), null, null);\r\n\t        else\r\n\t        \tsigref = xmlSigFactory.newReference(uri, xmlSigFactory.newDigestMethod(SIGNATURE_DIGEST_METHOD, null), null, null, null);\r\n            SignedInfo signedInfo = xmlSigFactory.newSignedInfo(\r\n            \t\txmlSigFactory.newCanonicalizationMethod(CANONICALIZATION_METHOD, (C14NMethodParameterSpec) null),\r\n            \t\txmlSigFactory.newSignatureMethod(SIGNATURE_METHOD, null),\r\n            \t\tCollections.singletonList(sigref));\r\n            KeyInfo keyInfo = null;\r\n            if (signaturePublicCert != null) {\r\n\t            List<X509Certificate> list = new ArrayList<X509Certificate>();\r\n\t            list.add(signaturePublicCert);\r\n\t            X509Data kv = keyInfoFactory.newX509Data(list);\r\n\t            keyInfo = keyInfoFactory.newKeyInfo(Collections.singletonList(kv));\r\n            }\r\n            XMLSignature signature = xmlSigFactory.newXMLSignature(signedInfo, keyInfo, xmlObjs, null, null);\r\n            DOMSignContext dsc = new DOMSignContext(signatureKey, doc);\r\n            signature.sign(dsc);\r\n    \t} catch(Exception e) {\r\n    \t\tlogger.error(e.getMessage(), e);\r\n    \t\tthrow e;\r\n    \t} finally {\r\n    \t\tif (bis != null) try{bis.close();}catch(Exception e){}\r\n    \t}\r\n\t\tlogger.debug(\"<-- createSignedDoc()\");\r\n    \treturn doc;\r\n    }\r\n    \r\n    protected boolean signXML(String xmlInputFile, String signedXmlOutputFile, boolean transformXml, PrivateKey signatureKey, X509Certificate signaturePublicCert) throws Exception {\r\n\t\tlogger.debug(\"--> signXML(). xmlInputFile=\" + xmlInputFile + \", signedXmlOutputFile=\" + signedXmlOutputFile + \", transformXml=\" + transformXml);\r\n    \tboolean ret = false;\r\n        ByteArrayOutputStream baos = null;\r\n        BufferedOutputStream bos = null;\r\n        BufferedInputStream bis = null;\r\n    \ttry {\r\n    \t\tNode node;\r\n    \t\tTransformer trans;\r\n    \t\tNodeList nodeList;\r\n    \t\tboolean isTransformed = false;\r\n            if (transformXml) {\r\n\t            logger.debug(\"parsing xml....\" + new Date());\r\n\t            calcMsgDigestByParsingDoc(xmlInputFile);\r\n\t            isTransformed = true;\r\n\t    \t\tlogger.debug(\"parsing xml....done. \" + new Date());\r\n    \t\t} else\r\n    \t\t\tcalcMsgDigestNoTransformation(xmlInputFile);\r\n            Document doc = createSignedDoc(isTransformed, signatureKey, signaturePublicCert);\r\n    \t\tnodeList = doc.getElementsByTagName(\"DigestValue\");\r\n            if (nodeList.getLength() > 0) {\r\n            \tnode = nodeList.item(0);\r\n            \tnode = node.getFirstChild();\r\n            \tnode.setNodeValue(digestValue);\r\n            } else\r\n            \tthrow new Exception(\"Invalid document structure. Missing <DigestValue> content\");\r\n            signatureValue = null;\r\n            nodeList = doc.getElementsByTagName(\"SignedInfo\");\r\n            if (nodeList.getLength() > 0) {\r\n            \tnode = nodeList.item(0); \r\n                baos = new ByteArrayOutputStream();\r\n                trans = transformerFactory.newTransformer();\r\n                trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\r\n                trans.transform(new DOMSource(node), new StreamResult(baos));\r\n                baos.close();\r\n                if (!Init.isInitialized())\r\n                \tInit.init();\r\n                Canonicalizer canon = Canonicalizer.getInstance(CANONICALIZATION_METHOD);\r\n\t\t\t\tSignature signature = Signature.getInstance(SIGNATUER_ALGO);\r\n\t\t\t\tsignature.initSign(signatureKey);\r\n\t\t\t\tsignature.update(canon.canonicalize(baos.toByteArray()));\r\n\t\t\t\tbyte[] signatureBuf = signature.sign();\r\n    \t\t\tsignatureValue = Base64.encode(signatureBuf);\r\n    \t\t\tbaos = null;\r\n            } else\r\n            \tthrow new Exception(\"Invalid document structure. Missing <SignedInfo> content\");\r\n            nodeList = doc.getElementsByTagName(\"SignatureValue\");\r\n            if (nodeList.getLength() > 0)\r\n            \tnodeList.item(0).getFirstChild().setNodeValue(signatureValue);\r\n            else\r\n            \tthrow new Exception(\"Invalid document structure. Missing <SignatureValue> content\");\r\n            String textContent = null;\r\n    \t\tnodeList = doc.getElementsByTagName(\"Object\");\r\n            if (nodeList.getLength() > 0) {\r\n            \tnode = nodeList.item(0);\r\n            \tnode = node.getFirstChild();\r\n            \ttextContent = node.getTextContent();\r\n            } else\r\n            \tthrow new Exception(\"Invalid document structure. Missing <Object> content\");\r\n    \t\tbaos = new ByteArrayOutputStream();\r\n            trans = transformerFactory.newTransformer();\r\n            trans.transform(new DOMSource(doc), new StreamResult(baos));\r\n            baos.close();\r\n            String tmp = baos.toString();\r\n            baos = null;\r\n            int pos = tmp.indexOf(textContent);\r\n            if (pos == -1)\r\n            \tthrow new Exception(\"Invalid document structure or invalid transformation\");\r\n            String prefix = tmp.substring(0, pos);\r\n            String suffix = tmp.substring(pos + textContent.length());\r\n            bos = new BufferedOutputStream(new FileOutputStream(signedXmlOutputFile));\r\n            bos.write(prefix.getBytes());\r\n            bis = new BufferedInputStream(new FileInputStream(xmlInputFile));\r\n            int len;\r\n            boolean flag = true;\r\n            byte[] tmpBuf = new byte[bufSize];\r\n            while((len = bis.read(tmpBuf)) != -1) {\r\n\t\t\t\tif (flag) {\r\n\t\t\t\t\ttmp = new String(tmpBuf, 0, len);\r\n\t\t\t\t\tflag = false;\r\n\t\t\t\t\tif (tmp.startsWith(\"<?xml\")) {\r\n\t\t\t\t\t\tpos = tmp.indexOf(\">\");\r\n\t\t\t\t\t\tif (pos != -1) {\r\n\t\t\t\t\t\t\ttmp = tmp.substring(pos+1);\r\n\t\t\t\t\t\t\tif (tmp.startsWith(\"\\r\\n\"))\r\n\t\t\t\t\t\t\t\ttmp = tmp.substring(2);\r\n\t\t\t\t\t\t\tif (tmp.startsWith(\"\\n\"))\r\n\t\t\t\t\t\t\t\ttmp = tmp.substring(1);\r\n\t\t\t\t\t\t\tif (tmp.startsWith(\"\\r\"))\r\n\t\t\t\t\t\t\t\ttmp = tmp.substring(1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbos.write(tmp.getBytes());\r\n\t\t\t\t} else \r\n\t\t\t\t\tbos.write(tmpBuf, 0, len);\r\n            }\r\n        \tbos.write(suffix.getBytes());\r\n        \tret = true;\r\n    \t} catch(Exception e) {\r\n    \t\tlogger.error(e.getMessage(), e);\r\n    \t\tthrow e;\r\n    \t} finally {\r\n    \t\tif (bos != null) try{bos.close();}catch(Exception e){}\r\n    \t\tif (bis != null) try{bis.close();}catch(Exception e){}\r\n    \t\tif (baos != null) try{baos.close();}catch(Exception e){}\r\n    \t}\r\n    \tlogger.debug(\"<--signXML()\");\r\n    \treturn ret;\r\n    }\r\n\r\n    protected void printNode(Node node) {\r\n\t\tlogger.debug(\"--> printNode() \" + node.getNodeName());\r\n\t\tlogger.debug(\"prefix=\" + node.getPrefix() + \", baseuri=\" + \r\n\t\t\t\tnode.getBaseURI() + \", nsuri=\" + node.getNamespaceURI() + \", value=\" + node.getNodeValue());\r\n\t\tif (node.getFirstChild() != null) {\r\n\t\t\tlogger.debug(\"--> Child of \" + node.getNodeName() );\r\n\t\t\tprintNode(node.getFirstChild());\r\n\t\t\tlogger.debug(\"<-- Child of \" + node.getNodeName() );\r\n\t\t}\r\n\t\tif (node.getNextSibling() != null) {\r\n\t\t\tlogger.debug(\"--> Sibling of \" + node.getNodeName() );\r\n\t\t\tprintNode(node.getNextSibling());\r\n\t\t\tlogger.debug(\"<-- Sibling of \" + node.getNodeName() );\r\n\t\t}\r\n\t\tlogger.debug(\"<-- printNode() \" + node.getNodeName());\r\n\t}\r\n\t\r\n    public void signDOM(String xmlInputFile, String signedXmlOutputFile, PrivateKey signatureKey, X509Certificate signaturePublicKey) throws Exception {\r\n\t\tlogger.debug(\"--> signDOM(). xmlInputFile=\" + xmlInputFile + \", signedXmlOutputFile=\" + signedXmlOutputFile);\r\n\t\tBufferedOutputStream bos = null;\r\n    \ttry {\r\n\t    \tDocument doc = createSignedDoc(xmlInputFile, true, signatureKey, signaturePublicKey);\r\n\t    \tNodeList nodeList = doc.getElementsByTagName(\"DigestValue\");\r\n\t        if (nodeList.getLength() > 0)\r\n\t        \tdigestValue = nodeList.item(0).getFirstChild().getNodeValue();\r\n\t    \tnodeList = doc.getElementsByTagName(\"SignatureValue\");\r\n\t        if (nodeList.getLength() > 0)\r\n\t        \tsignatureValue = nodeList.item(0).getFirstChild().getNodeValue();\r\n\t    \tbos = new BufferedOutputStream(new FileOutputStream(signedXmlOutputFile));\r\n\t    \tTransformer transformer = transformerFactory.newTransformer();\r\n\t        transformer.transform(new DOMSource(doc), new StreamResult(bos));\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\tif (bos != null) try{bos.close();}catch(Exception e) {}\r\n\t\t}\r\n\t\tlogger.debug(\"<-- signDOM()\");\r\n    }\r\n    \r\n    public boolean signStreaming(String xmlInputFile, String signedXmlOutputFile, PrivateKey signatureKey, X509Certificate signaturePublicCert) throws Exception {\r\n\t\tlogger.debug(\"--> signStreaming(). xmlInputFile=\" + xmlInputFile + \", signedXmlOutputFile=\" + signedXmlOutputFile);\r\n    \tboolean flag = signXML(xmlInputFile, signedXmlOutputFile, false, signatureKey, signaturePublicCert);\r\n\t\tlogger.debug(\"<-- signStreaming()\");\r\n    \treturn flag;\r\n    }\r\n    \r\n    public boolean signStreamingWithCanonicalization(String xmlInputFile, String signedXmlOutputFile, PrivateKey signatureKey, X509Certificate signaturePublicCert) throws Exception {\r\n\t\tlogger.debug(\"--> signStreamingWithCanonicalization(). xmlInputFile=\" + xmlInputFile + \", signedXmlOutputFile=\" + signedXmlOutputFile);\r\n    \tboolean flag = signXML(xmlInputFile, signedXmlOutputFile, true, signatureKey, signaturePublicCert);\r\n\t\tlogger.debug(\"<-- signStreamingWithCanonicalization()\");\r\n\t\treturn flag;\r\n    }\r\n}\r\n\r\n```\r\n\r\n3. Add code for TestMain.java\r\n\r\n```\r\npackage fatca;\r\n\r\nimport java.security.PrivateKey;\r\nimport java.security.cert.X509Certificate;\r\n\r\nimport org.apache.log4j.Logger;\r\n\r\npublic class TestMain {\r\n\tprotected static Logger logger = Logger.getLogger(new Object(){}.getClass().getEnclosingClass().getName());\r\n\r\n\t\r\n\t\r\n\tprivate FATCAXmlSigner signer = null;\r\n\tprivate FATCAPackager pkger = null;\r\n\r\n\t// sender FFI or HCTA\r\n\tprivate String canadaGiin = \"000000.00000.TA.124\";\r\n\tprivate PrivateKey canadaSigKey = null;\r\n\tprivate X509Certificate canadaPubCert = null;\r\n\t\r\n\t// receiver\r\n\tprivate String usaGiin = \"000000.00000.TA.840\";\r\n\tprivate X509Certificate usaCert = null;\r\n\tprivate PrivateKey usaPrivateKey = null; \r\n\t\r\n\t// approver - for model1 option2\r\n\tprivate String mexicoGiin = \"000000.00000.TA.484\";\r\n\tprivate X509Certificate mexicoPubCert = null;\r\n\tprivate PrivateKey mexicoPrivateKey = null; \r\n\t\r\n\tpublic TestMain() throws Exception{\r\n\t\tsigner = new FATCAXmlSigner();\r\n\t\tpkger = new FATCAPackager();\r\n\t\tcanadaSigKey = UtilShared.getPrivateKey(\"jks\", \"Keystore/Canada_PrepTool/KSprivateCA.jks\", \"pwd123\", \"CAN2014\", \"CANADAcert\");\r\n\t\tcanadaPubCert = UtilShared.getCert(\"jks\", \"Keystore/Canada_PrepTool/KSpublicCA.jks\", \"pwd123\", \"CANADAcert\");\r\n\t\tusaCert = UtilShared.getCert(\"jks\", \"Keystore/IRS_PrepTool/KSpublicUS.jks\", \"pwd123\", \"IRScert\");\r\n\t\tmexicoPubCert = UtilShared.getCert(\"jks\", \"Keystore/Mexico_PrepTool/KSpublicMX.jks\", \"pwd123\", \"MEXICOcert\");\r\n\t\tusaPrivateKey = UtilShared.getPrivateKey(\"jks\", \"Keystore/IRS_PrepTool/KSprivateUS.jks\", \"pwd123\", \"password\", \"IRScert\");\r\n\t\tmexicoPrivateKey = UtilShared.getPrivateKey(\"jks\", \"Keystore/Mexico_PrepTool/KSprivateMX.jks\", \"pwd123\", \"MEX2014\", \"MEXICOcert\");\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tString canadaXml = \"000000.00000.TA.124_0_Payload.xml\";\r\n\t\tString signedCanadaXml = canadaXml + \".signed\";\r\n\t\t\r\n\t\tFATCAPackager.isCanonicalization = false;\r\n\t\t\r\n\t\tTestMain m = new TestMain();\r\n\t\t\r\n\t\tm.signer.signStreaming(canadaXml, signedCanadaXml, m.canadaSigKey, m.canadaPubCert);\r\n\t\tm.signer.signDOM(canadaXml, signedCanadaXml, m.canadaSigKey, m.canadaPubCert);\r\n\t\t\r\n\t\tString idesOutFile = m.pkger.createPkg(signedCanadaXml, m.canadaGiin, m.usaGiin, m.usaCert, 2014);\r\n\t\tlogger.debug(idesOutFile);\r\n\r\n\t\tm.pkger.unpack(idesOutFile, m.usaPrivateKey);\r\n\t\t\r\n\t\tidesOutFile = m.pkger.createPkgWithApprover(signedCanadaXml, m.canadaGiin, m.usaGiin, m.usaCert, m.mexicoGiin, m.mexicoPubCert, 2014);\r\n\t\tlogger.debug(idesOutFile);\r\n\r\n\t\tm.pkger.unpackForApprover(idesOutFile, m.mexicoPrivateKey);\r\n\t\t\r\n\t\tidesOutFile = m.pkger.signAndCreatePkg(canadaXml, m.canadaSigKey, m.canadaPubCert, m.canadaGiin, m.usaGiin, m.usaCert, 2014);\r\n\t\tlogger.debug(idesOutFile);\r\n\r\n\t\tm.pkger.unpack(idesOutFile, m.usaPrivateKey);\r\n\t\t\r\n\t\tidesOutFile = m.pkger.signAndCreatePkgWithApprover(canadaXml, m.canadaSigKey, m.canadaPubCert, m.canadaGiin, m.usaGiin, m.usaCert, m.mexicoGiin, m.mexicoPubCert, 2014);\r\n\t\tlogger.debug(idesOutFile);\r\n\t\r\n\t\tm.pkger.unpackForApprover(idesOutFile, m.mexicoPrivateKey);\r\n\t}\r\n}\r\n\r\n```\r\n4. Add code for UtilShared.java\r\n\r\n```\r\npackage fatca;\r\n\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.security.KeyStore;\r\nimport java.security.PrivateKey;\r\nimport java.security.PublicKey;\r\nimport java.security.cert.X509Certificate;\r\nimport java.util.Enumeration;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.UUID;\r\n\r\nimport javax.xml.crypto.dsig.Reference;\r\nimport javax.xml.crypto.dsig.Transform;\r\nimport javax.xml.crypto.dsig.XMLSignature;\r\nimport javax.xml.crypto.dsig.XMLSignatureFactory;\r\nimport javax.xml.crypto.dsig.XMLSignature.SignatureValue;\r\nimport javax.xml.crypto.dsig.dom.DOMValidateContext;\r\nimport javax.xml.parsers.DocumentBuilder;\r\nimport javax.xml.parsers.DocumentBuilderFactory;\r\n\r\nimport org.apache.log4j.Logger;\r\nimport org.w3c.dom.Document;\r\nimport org.w3c.dom.Element;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\n\r\nimport com.sun.org.apache.xml.internal.security.utils.Base64;\r\n\r\npublic class UtilShared {\r\n\tprotected static Logger logger = Logger.getLogger(new Object(){}.getClass().getEnclosingClass().getName());\r\n\r\n\tpublic static String AES_TRANSFORMATION = \"AES/ECB/PKCS5Padding\";\r\n\tpublic static String RSA_TRANSFORMATION = \"RSA\";\r\n\t\r\n\tpublic static String SECRET_KEY_ALGO = \"AES\";\r\n\tpublic static int SECRET_KEY_SIZE = 256;\r\n\t\r\n\tpublic static String KEYSTORE_TYPE = \"pkcs12\";\r\n\tpublic static String CERTIFICATE_TYPE = \"X.509\";\r\n\t\r\n\tpublic static String genRandomId() {\r\n\t\tUUID uuid = UUID.randomUUID();\r\n\t\treturn uuid + \"@\" + System.identityHashCode(uuid);\r\n\t}\r\n\tpublic static X509Certificate getCert(String keystorefile, String keystorepwd) throws Exception {\r\n\t\treturn getCert(KEYSTORE_TYPE, keystorefile, keystorepwd, null);\r\n\t}\r\n\t\r\n\tpublic static X509Certificate getCert(String keystorefile, String keystorepwd, String alias) throws Exception {\r\n\t\treturn getCert(KEYSTORE_TYPE, keystorefile, keystorepwd, alias);\r\n\t}\r\n\t\r\n\tpublic static X509Certificate getCert(String keystoretype, String keystorefile, String keystorepwd, String alias) throws Exception {\r\n\t\ttry {\r\n\t\t\t//KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\r\n\t\t\tKeyStore keystore = KeyStore.getInstance(keystoretype);\r\n\t\t\tFileInputStream fis = new FileInputStream(keystorefile);\r\n\t\t\tkeystore.load(fis, keystorepwd.toCharArray());\r\n\t\t\tfis.close();\r\n\t\t\tif (alias == null) {\r\n\t\t\t\tEnumeration<String> e = keystore.aliases();\r\n\t\t\t\tif (e.hasMoreElements())\r\n\t\t\t\t\talias = e.nextElement();\r\n\t\t\t}\r\n\t\t\tif (alias != null) {\r\n\t\t\t\tX509Certificate cert = (X509Certificate)keystore.getCertificate(alias);\r\n\t\t\t\treturn cert;\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\tpublic static PrivateKey getPrivateKey(String keystorefile, String keystorepwd, String keypwd, String alias) throws Exception {\r\n\t\treturn getPrivateKey(KEYSTORE_TYPE, keystorefile, keystorepwd, keypwd, alias);\r\n\t}\r\n\t\r\n\tpublic static PrivateKey getPrivateKey(String keystorefile, String keystorepwd, String keypwd) throws Exception {\r\n\t\treturn getPrivateKey(KEYSTORE_TYPE, keystorefile, keystorepwd, keypwd, null);\r\n\t}\r\n\t\r\n\tpublic static PrivateKey getPrivateKey(String keystoretype, String keystorefile, String keystorepwd, String keypwd, String alias) throws Exception {\r\n\t\ttry {\r\n\t\t\t//KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\r\n\t\t\tKeyStore keystore = KeyStore.getInstance(keystoretype);\r\n\t\t\tFileInputStream fis = new FileInputStream(keystorefile);\r\n\t\t\tkeystore.load(fis, keystorepwd.toCharArray());\r\n\t\t\tfis.close();\r\n\t\t\tif (alias == null) {\r\n\t\t\t\tEnumeration<String> e = keystore.aliases();\r\n\t\t\t\tif (e.hasMoreElements())\r\n\t\t\t\t\talias = e.nextElement();\r\n\t\t\t}\r\n\t\t\tif (alias != null) {\r\n\t\t\t\tPrivateKey privkey = (PrivateKey)keystore.getKey(alias, keypwd.toCharArray());\r\n\t\t\t\tif (privkey == null)\r\n\t\t\t\t\tprivkey = (PrivateKey)keystore.getKey(alias.toLowerCase(), keypwd.toCharArray());\r\n\t\t\t\treturn privkey;\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic static boolean verifySignatureDOM(String signedPlainTextFile, PublicKey sigkey) throws Exception  {\r\n\t\tlogger.debug(\"--> verifySignatureDOM()\");\r\n\t\tboolean ret = false;\r\n\t\tXMLSignatureFactory xmlsigfac;\r\n\t\tXMLSignature signature;\r\n\t\tNodeList nl;\r\n\t\tDocumentBuilderFactory dbf;\r\n\t\tDocument doc;\r\n\t\tDOMValidateContext valContext;\r\n\t\tboolean coreValidity, sv, refValid;\r\n\t\tIterator<?> iter;\r\n\t\ttry {\r\n\t\t\txmlsigfac = XMLSignatureFactory.getInstance();\r\n\t\t\t\r\n\t\t    dbf = DocumentBuilderFactory.newInstance();\r\n\t        dbf.setNamespaceAware(true);\r\n\t        DocumentBuilder db = dbf.newDocumentBuilder();\r\n\t        \r\n\t        doc = db.parse(new File(signedPlainTextFile));\r\n\t        nl = doc.getElementsByTagNameNS(XMLSignature.XMLNS, \"Object\");\r\n\t\t\tif (nl.getLength() == 0)\r\n\t\t\t    throw new Exception(\"Cannot find Object element\");\r\n\t\t\tNode objNode = nl.item(0);\r\n\t    \r\n\t        String id = \"\";\r\n\t        Node attrId = objNode.getAttributes().getNamedItem(\"Id\");\r\n\t        if (attrId  != null)\r\n\t        \tid = attrId.getTextContent();\r\n\t\t\tElement fakeObjNode = doc.createElementNS(XMLSignature.XMLNS, \"Object\");\r\n\t\t\tfakeObjNode.setAttribute(\"Id\", id);\r\n\t\t\tdoc.getDocumentElement().replaceChild(fakeObjNode, objNode);\r\n\t    \tnl = doc.getElementsByTagNameNS(XMLSignature.XMLNS, \"Signature\");\r\n\t\t\tif (nl.getLength() == 0) {\r\n\t\t\t    throw new Exception(\"Cannot find Signature element\");\r\n\t\t\t}\r\n\t\t\tNode sigNode = nl.item(0);\r\n\r\n\t\t\tvalContext = new DOMValidateContext(sigkey, sigNode);\r\n\r\n\t        //very important\r\n\t        doc.getDocumentElement().replaceChild(objNode, fakeObjNode);\r\n\t\t\tsignature = xmlsigfac.unmarshalXMLSignature(valContext);\r\n\t\t\tcoreValidity = signature.validate(valContext);\r\n\t\t\t \r\n\t\t\tlogger.debug(\"Signature core validation \" + coreValidity);\r\n\t\t\t//if (coreValidity == false) {\r\n\t\t\t    SignatureValue sigval = signature.getSignatureValue();\r\n\t\t\t    sv = sigval.validate(valContext);\r\n\t\t\t    logger.debug(\"SignatureValue validation status: \" + sv);\r\n\t\t\t    //if (sv == false) {\r\n\t\t\t        // Check the validation status of each Reference.\r\n\t\t\t        iter = signature.getSignedInfo().getReferences().iterator();\r\n\t\t\t        Reference ref;\r\n\t\t\t        for (int j=0; iter.hasNext(); j++) {\r\n\t\t\t        \tref = (Reference) iter.next();\r\n\t\t\t        \trefValid = ref.validate(valContext);\r\n\t\t\t        \tlogger.debug(\"ref[\"+j+\"] validity status: \" + refValid);\r\n\t\t\t        \tlogger.debug(\"ref.getURI()=\" + ref.getURI());\r\n\t\t\t        \tlogger.debug(\"ref.getCalculatedDigestValue()=\" + Base64.encode(ref.getCalculatedDigestValue()));\r\n\t\t\t        \tlogger.debug(\"ref.getDigestValue()=\" + Base64.encode(ref.getDigestValue()));\r\n\t\t\t        \tList<?> lt = ref.getTransforms();\r\n\t\t\t        \tTransform tr;\r\n\t\t\t        \tfor (int i = 0; i < lt.size(); i++) {\r\n\t\t\t        \t\ttr = (Transform)lt.get(i);\r\n\t\t\t        \t\tlogger.debug(\"transform.getAlgorithm()=\" + tr.getAlgorithm());\r\n\t\t\t        \t}\r\n\t\t\t        }\r\n\t\t\t    //}\r\n\t\t\t//}\r\n\t\t\tret = coreValidity;\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t}\r\n\t\tlogger.debug(\"<-- verifySignatureDOM()\");\r\n\t\treturn ret;\r\n\t}\r\n}\r\n\r\n```\r\n\r\n##Test Payload file\r\nPlace the test Payload file from the repository .zip file into the root of the IDESDataPreparation folder. This is the FATCA Payload file that will be signed, encrypted, and packaged for transmission through IDES.\r\n\r\n![Image 10](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image10.png)  \r\nFigure 10  \r\n\r\n##log4j.xml file\r\nPlace the log4j.xml file from the repository .zip file into the root of the IDESDataPreparation/bin folder. This is the settings file for the console logging .jar.\r\n\r\n![Image 11](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image11.png)  \r\nFigure 11  \r\n\r\n##Project Contents\r\n\r\nRefreshing the contents of the project will show the newly added folders and files:\r\n![Image 12](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image12.png)  \r\nFigure 12  \r\n\r\n##Project Properties\r\n\r\nEnter the Project Properties screen and enter the Java Build Path selection:\r\n![Image 13](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image13.png)  \r\nFigure 13  \r\n\r\nAdd the **generated** folder to the **Source** tab and click OK\r\n![Image 14](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image14.png)  \r\nFigure 14  \r\n\r\nUpdated **Source** tab\r\n![Image 15](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image15.png)  \r\nFigure 15  \r\n\r\nSelect the **Libraries** tab\r\n![Image 16](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image16.png)  \r\nFigure 16  \r\n\r\nSelect the **Add JARs** button and browse to the log4j-1.2.16.jar file in the lib folder and click the OK button to add:\r\n![Image 17](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image17.png)  \r\nFigure 17\r\n\r\nUpdated **Libraries** tab\r\n![Image 18](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image18.png)  \r\nFigure 18  \r\n\r\n**Running The Application**\r\nHighlight the TestMain.java file located in the src\\fatca folder and start the application. The Console tab will display the logging information from the program.\r\n\r\n![Image 19](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image19.png)  \r\nFigure 19 \r\n\r\nThe output files will be placed in the root of the IDESDataPreparation folder:\r\n![Image 20](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image20.png)  \r\nFigure 20 \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}