{"name":"IDES Data Preparation - Java","tagline":"","body":"## IDES Data Preparation\r\nThe International Data Exchange Service (IDES) is a secure managed file transfer service that allows financial institutions and tax authorities to securely send information on financial accounts held by U.S. taxpayers in accordance with the Foreign Account Tax Compliance Act (FATCA). Files transmitted via IDES must be encrypted and packaged in accordance with published data preparation instructions.  The data preparation process is an important step to ensure that information transmitted via IDES conforms to U.S security standards to safeguard sensitive information.\r\n\r\nThe IDES Data Preparation Java project repository demonstrates a sample working application built using Java inside of [Eclipse](http://www.eclipse.org/).  An application was also developed using .Net, see [IDES Data Preparation .Net]  (http://irsgov.github.io/IDES-Data-Preparation-Dot-Net) for more information.\r\n\r\nThe example explains how to use the code to develop an application that will create an IDES data packet and decrypt notifications. The project starts with a validated FATCA XML file. The application does not validate the XML or metadata schemas. The sample application will digitally sign, encrypt, compress, and archive the data packet into a compliant .ZIP format.  \r\n\r\nPlease note that there are many open market tools that produce the same results; however, the IRS does not endorse any commercial products, including the frameworks used in the example.  \r\n\r\n### Application Setup\r\n\r\nThe sample application was created using Eclipse 4.4.1 and JRE version 1.8.0_40. \r\n\r\nThis repository includes a .zip file that contains several files necessary to this sample application. While some files can be copied and pasted from this guide, some must be downloaded from the .zip file and placed as indicated by the guide.\r\n\r\nKeystore - This folder contains a set of .jks files containing self-signed test public and private keys used by the application.\r\n\r\nlib - This folder contains the log4j-1.2.16.jar file which provides the console logging for the application.\r\n\r\ngenerated - This folder has a set of .java files related to the metadata used by the application.\r\n\r\nsrc - This folder has the main set of .java files, including testmain.java which is used to start the application.\r\n\r\n000000.00000.TA.124_0_Payload.xml - This is the FATCA XML that will be signed, encrypted, and packaged by the application. This is a test file for the application and is not intended to portray a specific business case.\r\n\r\n### Create a New Project  \r\n\r\nOpen **Eclipse**, select **New**, select **Java Project**. \r\n\r\n![Image 1](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image1.png)  \r\nFigure 1   \r\n \r\nEnter **IDESDataPreparation** for the Project Name and select the JRE that you will use. The sample is using jre1.8.0_40. Click the **Next** button.\r\n\r\n![Image 2](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image2.png)  \r\nFigure 2     \r\n\r\nClick **Finish**, these will be set up later\r\n\r\n![Image 3](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image3.png)  \r\nFigure 3\r\n\r\nThe Eclipse project with the default settings:\r\n![Image 4](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image4.png)  \r\nFigure 4\r\n\r\nThe file system for the new project:\r\n![Image 5](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image5.png)  \r\nFigure 5\r\n\r\n##generated folder\r\nAdd the generated folder from the .zip repository or replicate the folder structure below. \r\n![Image 6](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image6.png)  \r\nFigure 6\r\n\r\n1. Add code for FATCAEntCommunicationTypeCdType.java\r\n```\r\n//\r\n// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 \r\n// See <a href=\"http://java.sun.com/xml/jaxb\">http://java.sun.com/xml/jaxb</a> \r\n// Any modifications to this file will be lost upon recompilation of the source schema. \r\n// Generated on: 2014.11.05 at 11:20:51 AM EST \r\n//\r\n\r\n\r\npackage fatca.idessenderfilemetadata;\r\n\r\nimport javax.xml.bind.annotation.XmlEnum;\r\nimport javax.xml.bind.annotation.XmlType;\r\n\r\n\r\n/**\r\n * <p>Java class for FATCAEntCommunicationTypeCdType.\r\n * \r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n * <p>\r\n * <pre>\r\n * &lt;simpleType name=\"FATCAEntCommunicationTypeCdType\">\r\n *   &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}string\">\r\n *     &lt;enumeration value=\"NTF\"/>\r\n *     &lt;enumeration value=\"RPT\"/>\r\n *   &lt;/restriction>\r\n * &lt;/simpleType>\r\n * </pre>\r\n * \r\n */\r\n@XmlType(name = \"FATCAEntCommunicationTypeCdType\")\r\n@XmlEnum\r\npublic enum FATCAEntCommunicationTypeCdType {\r\n\r\n\r\n    /**\r\n     * FATCA_NOTIFICATION - FATCA Notification communication\r\n     * \r\n     */\r\n    NTF,\r\n\r\n    /**\r\n     * FATCA_REPORT - FATCA Report communication\r\n     * \r\n     */\r\n    RPT;\r\n\r\n    public String value() {\r\n        return name();\r\n    }\r\n\r\n    public static FATCAEntCommunicationTypeCdType fromValue(String v) {\r\n        return valueOf(v);\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n2. Add code for FATCAIDESSenderFileMetadataType.java\r\n```\r\n//\r\n// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 \r\n// See <a href=\"http://java.sun.com/xml/jaxb\">http://java.sun.com/xml/jaxb</a> \r\n// Any modifications to this file will be lost upon recompilation of the source schema. \r\n// Generated on: 2014.11.05 at 11:20:51 AM EST \r\n//\r\n\r\n\r\npackage fatca.idessenderfilemetadata;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\nimport javax.xml.datatype.XMLGregorianCalendar;\r\n\r\n\r\n/**\r\n * \r\n * \t\t\t\t\r\n * <pre>\r\n * &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Component xmlns=\"urn:fatca:idessenderfilemetadata\" xmlns:xmime=\"http://www.w3.org/2005/05/xmlmime\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"&gt;&lt;DictionaryEntryNm&gt;FATCA IDES Sender File Metadata Type&lt;/DictionaryEntryNm&gt;&lt;MajorVersionNum&gt;1&lt;/MajorVersionNum&gt;&lt;MinorVersionNum&gt;0&lt;/MinorVersionNum&gt;&lt;VersionEffectiveBeginDt&gt;2014-08-29&lt;/VersionEffectiveBeginDt&gt;&lt;VersionDescriptionTxt&gt;Initial Version&lt;/VersionDescriptionTxt&gt;&lt;Description&gt;Type for a group that defines the information contained in the FATCA IDES Sender File Metadata&lt;/Description&gt;\r\n * \t\t\t\t&lt;/Component&gt;\r\n * </pre>\r\n * \r\n * \t\t\t\r\n * \r\n * <p>Java class for FATCAIDESSenderFileMetadataType complex type.\r\n * \r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n * \r\n * <pre>\r\n * &lt;complexType name=\"FATCAIDESSenderFileMetadataType\">\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;sequence>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}FATCAEntitySenderId\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}FATCAEntityReceiverId\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}FATCAEntCommunicationTypeCd\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}SenderFileId\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}FileCreateTs\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}TaxYear\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}FileRevisionInd\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}OriginalIDESTransmissionId\" minOccurs=\"0\"/>\r\n *         &lt;element ref=\"{urn:fatca:idessenderfilemetadata}SenderContactEmailAddressTxt\" minOccurs=\"0\"/>\r\n *       &lt;/sequence>\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n * \r\n * \r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"FATCAIDESSenderFileMetadataType\", propOrder = {\r\n    \"fatcaEntitySenderId\",\r\n    \"fatcaEntityReceiverId\",\r\n    \"fatcaEntCommunicationTypeCd\",\r\n    \"senderFileId\",\r\n    \"fileCreateTs\",\r\n    \"taxYear\",\r\n    \"fileRevisionInd\",\r\n    \"originalIDESTransmissionId\",\r\n    \"senderContactEmailAddressTxt\"\r\n})\r\npublic class FATCAIDESSenderFileMetadataType {\r\n\r\n    @XmlElement(name = \"FATCAEntitySenderId\", required = true)\r\n    protected String fatcaEntitySenderId;\r\n    @XmlElement(name = \"FATCAEntityReceiverId\", required = true)\r\n    protected String fatcaEntityReceiverId;\r\n    @XmlElement(name = \"FATCAEntCommunicationTypeCd\", required = true)\r\n    protected FATCAEntCommunicationTypeCdType fatcaEntCommunicationTypeCd;\r\n    @XmlElement(name = \"SenderFileId\", required = true)\r\n    protected String senderFileId;\r\n    @XmlElement(name = \"FileCreateTs\", required = true)\r\n    protected String fileCreateTs;\r\n    @XmlElement(name = \"TaxYear\", required = true)\r\n    protected XMLGregorianCalendar taxYear;\r\n    @XmlElement(name = \"FileRevisionInd\")\r\n    protected boolean fileRevisionInd;\r\n    @XmlElement(name = \"OriginalIDESTransmissionId\")\r\n    protected String originalIDESTransmissionId;\r\n    @XmlElement(name = \"SenderContactEmailAddressTxt\")\r\n    protected String senderContactEmailAddressTxt;\r\n\r\n    /**\r\n     * Gets the value of the fatcaEntitySenderId property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public String getFATCAEntitySenderId() {\r\n        return fatcaEntitySenderId;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the fatcaEntitySenderId property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public void setFATCAEntitySenderId(String value) {\r\n        this.fatcaEntitySenderId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fatcaEntityReceiverId property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public String getFATCAEntityReceiverId() {\r\n        return fatcaEntityReceiverId;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the fatcaEntityReceiverId property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public void setFATCAEntityReceiverId(String value) {\r\n        this.fatcaEntityReceiverId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fatcaEntCommunicationTypeCd property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link FATCAEntCommunicationTypeCdType }\r\n     *     \r\n     */\r\n    public FATCAEntCommunicationTypeCdType getFATCAEntCommunicationTypeCd() {\r\n        return fatcaEntCommunicationTypeCd;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the fatcaEntCommunicationTypeCd property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link FATCAEntCommunicationTypeCdType }\r\n     *     \r\n     */\r\n    public void setFATCAEntCommunicationTypeCd(FATCAEntCommunicationTypeCdType value) {\r\n        this.fatcaEntCommunicationTypeCd = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the senderFileId property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public String getSenderFileId() {\r\n        return senderFileId;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the senderFileId property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public void setSenderFileId(String value) {\r\n        this.senderFileId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fileCreateTs property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public String getFileCreateTs() {\r\n        return fileCreateTs;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the fileCreateTs property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public void setFileCreateTs(String value) {\r\n        this.fileCreateTs = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the taxYear property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link XMLGregorianCalendar }\r\n     *     \r\n     */\r\n    public XMLGregorianCalendar getTaxYear() {\r\n        return taxYear;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the taxYear property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link XMLGregorianCalendar }\r\n     *     \r\n     */\r\n    public void setTaxYear(XMLGregorianCalendar value) {\r\n        this.taxYear = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fileRevisionInd property.\r\n     * \r\n     */\r\n    public boolean isFileRevisionInd() {\r\n        return fileRevisionInd;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the fileRevisionInd property.\r\n     * \r\n     */\r\n    public void setFileRevisionInd(boolean value) {\r\n        this.fileRevisionInd = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the originalIDESTransmissionId property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public String getOriginalIDESTransmissionId() {\r\n        return originalIDESTransmissionId;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the originalIDESTransmissionId property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public void setOriginalIDESTransmissionId(String value) {\r\n        this.originalIDESTransmissionId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the senderContactEmailAddressTxt property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public String getSenderContactEmailAddressTxt() {\r\n        return senderContactEmailAddressTxt;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the senderContactEmailAddressTxt property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public void setSenderContactEmailAddressTxt(String value) {\r\n        this.senderContactEmailAddressTxt = value;\r\n    }\r\n\r\n}\r\n\r\n3. Add code for ObjectFactory.java\r\n```\r\n//\r\n// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 \r\n// See <a href=\"http://java.sun.com/xml/jaxb\">http://java.sun.com/xml/jaxb</a> \r\n// Any modifications to this file will be lost upon recompilation of the source schema. \r\n// Generated on: 2014.11.05 at 11:20:51 AM EST \r\n//\r\n\r\n\r\npackage fatca.idessenderfilemetadata;\r\n\r\nimport javax.xml.bind.JAXBElement;\r\nimport javax.xml.bind.annotation.XmlElementDecl;\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\nimport javax.xml.datatype.XMLGregorianCalendar;\r\nimport javax.xml.namespace.QName;\r\n\r\n\r\n/**\r\n * This object contains factory methods for each \r\n * Java content interface and Java element interface \r\n * generated in the fatca.idessenderfilemetadata package. \r\n * <p>An ObjectFactory allows you to programatically \r\n * construct new instances of the Java representation \r\n * for XML content. The Java representation of XML \r\n * content can consist of schema derived interfaces \r\n * and classes representing the binding of schema \r\n * type definitions, element declarations and model \r\n * groups.  Factory methods for each of these are \r\n * provided in this class.\r\n * \r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    private final static QName _SenderFileId_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"SenderFileId\");\r\n    private final static QName _FATCAEntCommunicationTypeCd_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"FATCAEntCommunicationTypeCd\");\r\n    private final static QName _TaxYear_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"TaxYear\");\r\n    private final static QName _FileRevisionInd_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"FileRevisionInd\");\r\n    private final static QName _FATCAIDESSenderFileMetadata_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"FATCAIDESSenderFileMetadata\");\r\n    private final static QName _SenderContactEmailAddressTxt_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"SenderContactEmailAddressTxt\");\r\n    private final static QName _FATCAEntitySenderId_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"FATCAEntitySenderId\");\r\n    private final static QName _FATCAEntityReceiverId_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"FATCAEntityReceiverId\");\r\n    private final static QName _OriginalIDESTransmissionId_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"OriginalIDESTransmissionId\");\r\n    private final static QName _FileCreateTs_QNAME = new QName(\"urn:fatca:idessenderfilemetadata\", \"FileCreateTs\");\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fatca.idessenderfilemetadata\r\n     * \r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link FATCAIDESSenderFileMetadataType }\r\n     * \r\n     */\r\n    public FATCAIDESSenderFileMetadataType createFATCAIDESSenderFileMetadataType() {\r\n        return new FATCAIDESSenderFileMetadataType();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"SenderFileId\")\r\n    public JAXBElement<String> createSenderFileId(String value) {\r\n        return new JAXBElement<String>(_SenderFileId_QNAME, String.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link FATCAEntCommunicationTypeCdType }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"FATCAEntCommunicationTypeCd\")\r\n    public JAXBElement<FATCAEntCommunicationTypeCdType> createFATCAEntCommunicationTypeCd(FATCAEntCommunicationTypeCdType value) {\r\n        return new JAXBElement<FATCAEntCommunicationTypeCdType>(_FATCAEntCommunicationTypeCd_QNAME, FATCAEntCommunicationTypeCdType.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link XMLGregorianCalendar }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"TaxYear\")\r\n    public JAXBElement<XMLGregorianCalendar> createTaxYear(XMLGregorianCalendar value) {\r\n        return new JAXBElement<XMLGregorianCalendar>(_TaxYear_QNAME, XMLGregorianCalendar.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link Boolean }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"FileRevisionInd\")\r\n    public JAXBElement<Boolean> createFileRevisionInd(Boolean value) {\r\n        return new JAXBElement<Boolean>(_FileRevisionInd_QNAME, Boolean.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link FATCAIDESSenderFileMetadataType }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"FATCAIDESSenderFileMetadata\")\r\n    public JAXBElement<FATCAIDESSenderFileMetadataType> createFATCAIDESSenderFileMetadata(FATCAIDESSenderFileMetadataType value) {\r\n        return new JAXBElement<FATCAIDESSenderFileMetadataType>(_FATCAIDESSenderFileMetadata_QNAME, FATCAIDESSenderFileMetadataType.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"SenderContactEmailAddressTxt\")\r\n    public JAXBElement<String> createSenderContactEmailAddressTxt(String value) {\r\n        return new JAXBElement<String>(_SenderContactEmailAddressTxt_QNAME, String.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"FATCAEntitySenderId\")\r\n    public JAXBElement<String> createFATCAEntitySenderId(String value) {\r\n        return new JAXBElement<String>(_FATCAEntitySenderId_QNAME, String.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"FATCAEntityReceiverId\")\r\n    public JAXBElement<String> createFATCAEntityReceiverId(String value) {\r\n        return new JAXBElement<String>(_FATCAEntityReceiverId_QNAME, String.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"OriginalIDESTransmissionId\")\r\n    public JAXBElement<String> createOriginalIDESTransmissionId(String value) {\r\n        return new JAXBElement<String>(_OriginalIDESTransmissionId_QNAME, String.class, null, value);\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link JAXBElement }{@code <}{@link String }{@code >}}\r\n     * \r\n     */\r\n    @XmlElementDecl(namespace = \"urn:fatca:idessenderfilemetadata\", name = \"FileCreateTs\")\r\n    public JAXBElement<String> createFileCreateTs(String value) {\r\n        return new JAXBElement<String>(_FileCreateTs_QNAME, String.class, null, value);\r\n    }\r\n\r\n}\r\n\r\n4. Add code for package-info.java\r\n```\r\n//\r\n// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 \r\n// See <a href=\"http://java.sun.com/xml/jaxb\">http://java.sun.com/xml/jaxb</a> \r\n// Any modifications to this file will be lost upon recompilation of the source schema. \r\n// Generated on: 2014.11.05 at 11:20:51 AM EST \r\n//\r\n\r\n@javax.xml.bind.annotation.XmlSchema(namespace = \"urn:fatca:idessenderfilemetadata\", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)\r\npackage fatca.idessenderfilemetadata;\r\n\r\n```\r\n\r\n##Keystore\r\nPlace the Keystore folder from the repository .zip file into the IDESDataPreparation folder. This will contain the test keys that the program will use. \r\n\r\n![Image 7](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image7.png)  \r\nFigure 7  \r\n\r\n##lib folder\r\nPlace the lib folder from the repository .zip file into the IDESDataPreparation folder. This will contain the .jar file for the console logging functionality.\r\n\r\n![Image 8](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image8.png)  \r\nFigure 8  \r\n\r\n##src folder\r\nAdd the src folder from the .zip repository or replicate the folder structure below. \r\n![Image 9](http://irsgov.github.io/IDES-Data-Preparation-Java/images/image9.png)  \r\nFigure 9\r\n\r\n1. Add code for FATCAPackager.java\r\n\r\n```\r\npackage fatca;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.BufferedOutputStream;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.FileWriter;\r\nimport java.net.URI;\r\nimport java.nio.file.FileSystem;\r\nimport java.nio.file.FileSystems;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.StandardCopyOption;\r\nimport java.security.PrivateKey;\r\nimport java.security.PublicKey;\r\nimport java.security.cert.Certificate;\r\nimport java.security.cert.X509Certificate;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Date;\r\nimport java.util.Enumeration;\r\nimport java.util.GregorianCalendar;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.zip.Deflater;\r\nimport java.util.zip.ZipEntry;\r\nimport java.util.zip.ZipFile;\r\nimport java.util.zip.ZipOutputStream;\r\n\r\nimport javax.crypto.Cipher;\r\nimport javax.crypto.KeyGenerator;\r\nimport javax.crypto.SecretKey;\r\nimport javax.xml.bind.JAXBContext;\r\nimport javax.xml.bind.JAXBElement;\r\nimport javax.xml.bind.Marshaller;\r\nimport javax.xml.bind.Unmarshaller;\r\nimport javax.xml.datatype.DatatypeConstants;\r\nimport javax.xml.datatype.XMLGregorianCalendar;\r\n\r\nimport org.apache.log4j.Logger;\r\n\r\nimport com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;\r\n\r\nimport fatca.idessenderfilemetadata.FATCAEntCommunicationTypeCdType;\r\nimport fatca.idessenderfilemetadata.FATCAIDESSenderFileMetadataType;\r\n\r\npublic class FATCAPackager {\r\n\tpublic static String AES_TRANSFORMATION = \"AES/ECB/PKCS5Padding\";\r\n\tpublic static String RSA_TRANSFORMATION = \"RSA\";\r\n\tpublic static String SECRET_KEY_ALGO = \"AES\";\r\n\tpublic static int SECRET_KEY_SIZE = 256;\r\n\r\n\tpublic static String metadataEmailAddress=\"none@email.com\";\r\n\tpublic static int bufSize = 64 * 1024;\r\n\r\n\tpublic static boolean isCanonicalization = true;\r\n\t\r\n\tprotected static Logger logger = Logger.getLogger(new Object(){}.getClass().getEnclosingClass().getName());\r\n\r\n\tprotected FATCAXmlSigner signer = new FATCAXmlSigner();\r\n\tprotected Long fileId = 0L;\r\n\tprotected fatca.idessenderfilemetadata.ObjectFactory objFMetadata = new fatca.idessenderfilemetadata.ObjectFactory();\r\n\tprotected SimpleDateFormat sdfFileName = new SimpleDateFormat(\"yyyyMMdd'T'HHmmssSSS'Z'\");\r\n\tprotected SimpleDateFormat sdfFileCreateTs = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\r\n\t\r\n\tprotected int maxAttempts = 5;\r\n\t\r\n\tprotected boolean aes(int opmode, String inputFile, String outputFile, SecretKey secretKey) throws Exception {\r\n\t\tlogger.debug(\"--> aes(). opmode=\" + (opmode==Cipher.ENCRYPT_MODE?\"ENCRYPT\":\"DECRYPT\") + \r\n\t\t\t\", inputFile=\" + inputFile + \", outputFile=\" + outputFile);\r\n\t\tif (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE)\r\n\t\t\tthrow new Exception(\"Invalid opmode \" + opmode + \". Allowed opmodes are Cipher.ENCRYPT_MODE or Cipher.DECRYPT_MODE\");\r\n\t\tboolean ret = false;\r\n\t\tBufferedInputStream bis = null;\r\n\t\tBufferedOutputStream bos = null;\r\n\t\tint len;\r\n\t\tbyte[] output = null;\r\n\t\tbyte[] buf = new byte[bufSize];\r\n\t\tCipher cipher;\r\n\t\ttry {\r\n\t\t\tcipher = Cipher.getInstance(AES_TRANSFORMATION);\r\n\t\t\tcipher.init(opmode, secretKey);\r\n\t\t\tbis = new BufferedInputStream(new FileInputStream(inputFile));\r\n\t\t\tbos = new BufferedOutputStream(new FileOutputStream(outputFile));\r\n\t\t\twhile((len = bis.read(buf)) != -1) {\r\n\t\t\t\t//output = cipher.update(Arrays.copyOf(buf, len));\r\n\t\t\t\toutput = cipher.update(buf, 0, len);\r\n\t\t\t\tif (output.length > 0)\r\n\t\t\t\t\tbos.write(output);\r\n\t\t\t}\r\n\t\t\toutput = cipher.doFinal();\r\n\t\t\tif (output.length > 0)\r\n\t\t\t\tbos.write(output);\r\n\t\t\tbos.close(); bos = null;\r\n\t\t\tbis.close(); bis = null; \r\n\t\t\tret = true;\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\tif (bis != null) try{bis.close();}catch(Exception e) {}\r\n\t\t\tif (bos != null) try{bos.close();}catch(Exception e) {}\r\n\t\t}\r\n\t\tlogger.debug(\"<-- aes()\");\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tprotected boolean encrypt(String zippedSignedPlainTextFile, String cipherTextOutFile, Certificate[] receiversPublicCert,\r\n\t\t\tString[] encryptedAESKeyOutFiles) throws Exception {\r\n\t\tlogger.debug(\"--> encrypt(). zippedSignedPlainTextFile=\" + zippedSignedPlainTextFile + \", cipherTextOutFile=\" + cipherTextOutFile);\r\n\t\tPublicKey[] pubkeys = new PublicKey[receiversPublicCert.length];\r\n\t\tfor (int i = 0; i < receiversPublicCert.length; i++)\r\n\t\t\tpubkeys[i] = receiversPublicCert[i].getPublicKey();\r\n\t\tboolean flag = encrypt(zippedSignedPlainTextFile, cipherTextOutFile, pubkeys, encryptedAESKeyOutFiles);\r\n\t\tlogger.debug(\"<-- encrypt()\");\r\n\t\treturn flag;\r\n\t}\r\n\t\r\n\tprotected boolean encrypt(String zippedSignedPlainTextFile, String cipherTextOutFile, PublicKey[] receiversPublicKey,\r\n\t\t\tString[] encryptedAESKeyOutFiles) throws Exception {\r\n\t\tlogger.debug(\"--> encrypt(). zippedSignedPlainTextFile=\" + zippedSignedPlainTextFile + \", cipherTextOutFile\" + cipherTextOutFile);\r\n\t\tboolean ret = false;\r\n\t\tSecretKey skey = null;\r\n\t\tKeyGenerator generator;\r\n\t\tbyte[] encryptedAESKeyBuf;\r\n\t\tBufferedOutputStream bos = null;\r\n\t\tCipher cipher = null;\r\n\t\ttry {\r\n\t\t\tgenerator = KeyGenerator.getInstance(SECRET_KEY_ALGO);\r\n\t\t\tgenerator.init(SECRET_KEY_SIZE);\r\n\t\t\tskey = generator.generateKey();\r\n\t\t\tret = aes(Cipher.ENCRYPT_MODE, zippedSignedPlainTextFile, cipherTextOutFile, skey);\r\n\t\t\tif (ret) {\r\n\t\t\t\tfor (int i = 0; i < receiversPublicKey.length && i < encryptedAESKeyOutFiles.length; i++) {\r\n\t\t\t\t\tif (cipher == null)\r\n\t\t\t\t\t\tcipher = Cipher.getInstance(RSA_TRANSFORMATION);\r\n\t\t\t\t\tcipher.init(Cipher.WRAP_MODE, receiversPublicKey[i]);\r\n\t\t\t\t\tencryptedAESKeyBuf = cipher.wrap(skey);\r\n\t\t\t\t\tbos = new BufferedOutputStream(new FileOutputStream(encryptedAESKeyOutFiles[i]));\r\n\t\t\t\t\tbos.write(encryptedAESKeyBuf);\r\n\t\t\t\t\tbos.close(); bos = null;\r\n\t\t\t\t}\r\n\t\t\t\tret = true;\r\n\t\t\t}\r\n\t\t} catch(Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\tif (bos != null) try{bos.close();}catch(Exception e) {}\r\n\t\t}\r\n\t\tlogger.debug(\"<-- encrypt)\");\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tprotected boolean renameZipEntry(String zipFile, String entryName, String newEntryName) throws Exception {\r\n\t\tlogger.debug(\"--> renameZipEntry(). zipFile=\" + zipFile + \", entryName=\" + entryName + \", newEntryName=\" + newEntryName);\r\n\t\tboolean ret = false;\r\n        Map<String, String> props = new HashMap<String, String>(); \r\n        props.put(\"create\", \"false\"); \r\n        try {\r\n            URI zipDisk = URI.create(\"jar:\" + new File(zipFile).toURI());\r\n            FileSystem zipfs = FileSystems.newFileSystem(zipDisk, props);\r\n            Path pathInZipfile = zipfs.getPath(entryName);\r\n            Path renamedZipEntry = zipfs.getPath(newEntryName);\r\n            Files.move(pathInZipfile,renamedZipEntry, StandardCopyOption.ATOMIC_MOVE);\r\n            zipfs.close();\r\n            ret = true;\r\n        } catch(Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n        }\r\n\t\tlogger.debug(\"<-- renameZipEntry()\");\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tprotected boolean renameZipEntries(String zipFile, String[] entryNames, String[] newEntryNames) throws Exception {\r\n\t\tif (logger.isDebugEnabled()) {\r\n\t\t\tStringBuilder sb = new StringBuilder(\"--> renameZipEntries()\");\r\n\t\t\tsb.append(\", zipFile=\");\r\n\t\t\tsb.append(zipFile);\r\n\t\t\tsb.append(\", entryNames=[\");\r\n\t\t\tfor (int i = 0; i < entryNames.length; i++) {\r\n\t\t\t\tif (i > 0) sb.append(\",\");\r\n\t\t\t\tsb.append(entryNames[i]);\r\n\t\t\t}\r\n\t\t\tsb.append(\"], newEntryNames=[\");\r\n\t\t\tfor (int i = 0; i < newEntryNames.length; i++) {\r\n\t\t\t\tif (i > 0) sb.append(\",\");\r\n\t\t\t\tsb.append(newEntryNames[i]);\r\n\t\t\t}\r\n\t\t\tsb.append(\"]\");\r\n\t\t\tlogger.debug(sb.toString());\r\n\t\t}\r\n\t\tboolean ret = false;\r\n\t\tif (entryNames.length != newEntryNames.length)\r\n\t\t\tthrow new Exception(\"renameZipEntries entryNames and newEntryNames length should be same\");\r\n        Map<String, String> props = new HashMap<String, String>(); \r\n        props.put(\"create\", \"false\"); \r\n        try {\r\n            URI zipDisk = URI.create(\"jar:\" + new File(zipFile).toURI());\r\n        \tFileSystem zipfs = FileSystems.newFileSystem(zipDisk, props);\r\n        \tPath pathInZipfile, renamedZipEntry;\r\n        \tfor (int i = 0; i < entryNames.length; i++) {\r\n                pathInZipfile = zipfs.getPath(entryNames[i]);\r\n                renamedZipEntry = zipfs.getPath(newEntryNames[i]);\r\n                Files.move(pathInZipfile,renamedZipEntry, StandardCopyOption.ATOMIC_MOVE);\r\n        \t}\r\n            zipfs.close();\r\n            ret = true;\r\n        } catch(Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n        }\r\n\t\tlogger.debug(\"<-- renameZipEntries()\");\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tprotected boolean createZipFile(String[] inFiles, String outFile) throws Exception {\r\n\t\tif (logger.isDebugEnabled()) {\r\n\t\t\tStringBuilder sb = new StringBuilder(\"--> createZipFile()\");\r\n\t\t\tsb.append(\", inFiles=[\");\r\n\t\t\tfor (int i = 0; i < inFiles.length; i++) {\r\n\t\t\t\tif (i > 0) sb.append(\",\");\r\n\t\t\t\tsb.append(inFiles[i]);\r\n\t\t\t}\r\n\t\t\tsb.append(\"], outFile=\");\r\n\t\t\tsb.append(outFile);\r\n\t\t\tlogger.debug(sb.toString());\r\n\t\t}\r\n\t\tBufferedInputStream bis = null;\r\n\t\tZipOutputStream zos = null;\r\n\t\tZipEntry zipEntry;\r\n\t\tint len;\r\n\t\tboolean ret = false;\r\n\t\tString infile;\r\n\t\tbyte[] buf = new byte[bufSize];\r\n\t\ttry {\r\n\t\t\tzos = new ZipOutputStream(new FileOutputStream(outFile));\r\n\t\t\tzos.setLevel(Deflater.BEST_COMPRESSION);\r\n\t\t\tfor (int i = 0; i < inFiles.length; i++) {\r\n\t\t\t\t// drop folder names\r\n\t\t\t\tinfile = inFiles[i];\r\n\t\t\t\tlen = infile.lastIndexOf(\"/\");\r\n\t\t\t\tif (len == -1)\r\n\t\t\t\t\tlen = infile.lastIndexOf(\"\\\\\");\r\n\t\t\t\tif (len != -1)\r\n\t\t\t\t\tinfile = infile.substring(len+1);\r\n\t\t\t\tzipEntry = new ZipEntry(infile);\r\n\t\t\t\tzos.putNextEntry(zipEntry);\r\n\t\t\t\tbis = new BufferedInputStream(new FileInputStream(inFiles[i]));\r\n\t\t\t\twhile((len = bis.read(buf)) != -1)\r\n\t\t\t\t\tzos.write(buf, 0, len);\r\n\t\t\t\tbis.close(); bis = null;\r\n\t\t\t\tzos.closeEntry();\r\n\t\t\t}\r\n\t\t\tzos.close(); zos = null;\r\n\t\t\tret = true;\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\tif (bis != null) try{bis.close();}catch(Exception e) {}\r\n\t\t\tif (zos != null) try{zos.close();}catch(Exception e) {}\r\n\t\t}\r\n\t\tlogger.debug(\"<-- createZipFile()\");\r\n    \treturn ret;\r\n\t}\r\n\r\n\tprotected ArrayList<String> unzipFile(String inFile) throws Exception {\r\n\t\treturn unzipFile(inFile, null);\r\n\t}\r\n\t\r\n\tprotected ArrayList<String> unzipFile(String inFile, String extractFolder) throws Exception {\r\n\t\tlogger.debug(\"--> unzipFile(). inFile=\" + inFile + \", extractFolder=\" + extractFolder);\r\n    \tBufferedInputStream bis = null;\r\n    \tBufferedOutputStream bos = null;\r\n    \tint len;\r\n    \tZipFile zipFile = null;\r\n    \tEnumeration<? extends ZipEntry> entries;\r\n    \tZipEntry entry;\r\n    \tArrayList<String> entryList = null;\r\n    \tbyte[] buf = new byte[bufSize];\r\n    \tString outFile;\r\n\t\ttry {\r\n\t\t\tif (extractFolder == null)\r\n\t\t\t\textractFolder = \".\";\r\n\t\t\tif (!extractFolder.endsWith(\"/\") && !extractFolder.endsWith(\"\\\\\"))\r\n\t\t\t\textractFolder += \"/\";\r\n\t\t\tzipFile = new ZipFile(inFile);\r\n\t    \tentries = zipFile.entries();\r\n\t    \twhile (entries.hasMoreElements()) {\r\n\t    \t\tif (entryList == null)\r\n\t\t    \t\tentryList = new ArrayList<String>();\r\n\t    \t\tentry = entries.nextElement();\r\n\t    \t\toutFile = extractFolder + entry.getName();\r\n\t    \t\tentryList.add(outFile);\r\n\t    \t\tbis = new BufferedInputStream(zipFile.getInputStream(entry));\r\n\t    \t\tbos = new BufferedOutputStream(new FileOutputStream(outFile));\r\n\t    \t\twhile((len = bis.read(buf)) != -1)\r\n\t    \t\t\tbos.write(buf, 0, len);\r\n\t    \t\tbos.close(); bos = null;\r\n\t    \t\tbis.close(); bis = null;\r\n\t    \t}\r\n\t    \tzipFile.close(); zipFile = null;\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\tif (bis != null) try{bis.close();}catch(Exception e) {}\r\n\t\t\tif (bos != null) try{bos.close();}catch(Exception e) {}\r\n\t\t\tif (zipFile != null) try{zipFile.close();}catch(Exception e) {}\r\n\t\t}\r\n\t\tlogger.debug(\"<-- unzipFile()\");\r\n\t\treturn entryList;\r\n\t}\r\n\r\n\t//_Payload.xml,_Metadata.xml, _Payload.zip, _Key, _Payload\r\n\tprotected String getFileName(String senderGiin, String filename) throws Exception {\r\n\t\tsynchronized (fileId) {\r\n\t\t\tlogger.debug(\"--> getFileName(). senderGiin=\" + senderGiin + \", filename=\" + filename);\r\n\t\t\tif (fileId == Long.MAX_VALUE) fileId = 0L;\r\n\t\t\tString xmlfilename = senderGiin + \"_\" + fileId++ + filename;\r\n\t\t\tFile file = new File(xmlfilename);\r\n\t\t\tint attempts = maxAttempts;\r\n\t\t\twhile(!file.createNewFile() && attempts-- > 0) {\r\n\t\t\t\txmlfilename = senderGiin + \"_\" + fileId++ + filename;\r\n\t\t\t\tfile = new File(xmlfilename);\r\n\t\t\t}\r\n\t\t\tif (attempts <= 0)\r\n\t\t\t\tthrow new Exception (\"Unable to getFileName() - file=\" + file.getAbsolutePath());\r\n\t\t\tlogger.debug(\"<-- getFileName()\");\r\n\t\t\treturn xmlfilename;\r\n\t\t}\r\n\t}\r\n\t\r\n\tprotected String getIDESFileName(String senderGiin) throws Exception {\r\n\t\tsynchronized (fileId) {\r\n\t\t\tlogger.debug(\"--> getIDESFileName(). senderGiin=\" + senderGiin);\r\n\t\t\tDate date = new Date();\r\n\t\t\tString outfile = sdfFileName.format(date) + \"_\" + senderGiin + \".zip\";\r\n\t\t\tFile file = new File(outfile);\r\n\t\t\tint attempts = maxAttempts;\r\n\t\t\twhile (!file.createNewFile() && attempts-- > 0) {\r\n\t\t\t\toutfile = sdfFileName.format(new Date()) + \"_\" + senderGiin + \".zip\";\r\n\t\t\t\tfile = new File(outfile);\r\n\t\t\t}\r\n\t\t\tif (attempts <= 0)\r\n\t\t\t\tthrow new Exception (\"Unable to getFileName() - file=\" + file.getAbsolutePath());\r\n\t\t\tlogger.debug(\"<-- getIDESFileName()\");\r\n\t\t\treturn outfile;\r\n\t\t}\r\n\t}\r\n\t\r\n\tprotected XMLGregorianCalendar genTaxYear(int year) {\r\n\t\tXMLGregorianCalendar taxyear = new XMLGregorianCalendarImpl(new GregorianCalendar());\r\n\t\ttaxyear.setTimezone(DatatypeConstants.FIELD_UNDEFINED);\r\n\t\ttaxyear.setTime(DatatypeConstants.FIELD_UNDEFINED, DatatypeConstants.FIELD_UNDEFINED, DatatypeConstants.FIELD_UNDEFINED);\r\n\t\ttaxyear.setDay(DatatypeConstants.FIELD_UNDEFINED);\r\n\t\ttaxyear.setMonth(DatatypeConstants.FIELD_UNDEFINED);\r\n\t\ttaxyear.setYear(year);\r\n\t\treturn taxyear;\r\n\t}\r\n\t\r\n\tprotected String getFileName(String filename) {\r\n\t\tFile f = new File(filename);\r\n\t\treturn f.getName();\r\n\t}\r\n\t\r\n\tpublic String signAndCreatePkg(String unsignedXml, PrivateKey senderPrivateKey, X509Certificate senderPublicCert,\r\n\t\t\tString senderGiin, String receiverGiin, X509Certificate receiverPublicCert, int taxyear) throws Exception {\r\n\t\tlogger.debug(\"--> signAndCreatePkg(). unsignedXml=\" + unsignedXml + \", senderGiin=\" + senderGiin +\r\n\t\t\t\t\", receiverGiin=\" + receiverGiin + \", taxyear=\" + taxyear);\r\n\t\tString signedxml = unsignedXml + \".signed\";\r\n\t\tboolean success = false;\r\n\t\tString ret = null;\r\n\t\tif (isCanonicalization)\r\n\t\t\tsuccess = signer.signStreamingWithCanonicalization(unsignedXml, signedxml, senderPrivateKey, senderPublicCert);\r\n\t\telse\r\n\t\t\tsuccess = signer.signStreaming(unsignedXml, signedxml, senderPrivateKey, senderPublicCert);\r\n\t\tif (success)\r\n\t\t\tret = createPkgWithApprover(signedxml, senderGiin, receiverGiin, receiverPublicCert, null, null, taxyear);\r\n\t\tlogger.debug(\"<-- signAndCreatePkg()\");\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tpublic String signAndCreatePkgWithApprover(String unsignedxml, PrivateKey senderPrivateKey, X509Certificate senderPublicCert,\r\n\t\t\tString senderGiin, String receiverGiin, X509Certificate receiverPublicCert, String approverGiin, \r\n\t\t\tX509Certificate approvercert, int taxyear) throws Exception {\r\n\t\tlogger.debug(\"--> signAndCreatePkgWithApprover(). xmlfilename=\" + unsignedxml + \", senderGiin=\" + senderGiin +\r\n\t\t\t\t\", receiverGiin=\" + receiverGiin + \", approverGiin=\" + approverGiin + \", taxyear=\" + taxyear);\r\n\t\tString signedxml = unsignedxml + \".signed\";\r\n\t\tboolean success = false;\r\n\t\tString ret = null;\r\n\t\tif (isCanonicalization)\r\n\t\t\tsuccess = signer.signStreamingWithCanonicalization(unsignedxml, signedxml, senderPrivateKey, senderPublicCert);\r\n\t\telse\r\n\t\t\tsuccess = signer.signStreaming(unsignedxml, signedxml, senderPrivateKey, senderPublicCert);\r\n\t\tif (success)\r\n\t\t\tret = createPkgWithApprover(signedxml, senderGiin, receiverGiin, receiverPublicCert, approverGiin, approvercert, taxyear);\r\n\t\tlogger.debug(\"<-- signAndCreatePkgWithApprover()\");\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tpublic String createPkg(String signedXmlFile, String senderGiin, String receiverGiin,  \r\n\t\t\tX509Certificate receiverPublicCert, int taxyear) throws Exception {\r\n\t\treturn createPkgWithApprover(signedXmlFile, senderGiin, receiverGiin, receiverPublicCert, null, null, taxyear);\r\n\t}\r\n\t\r\n\tpublic String createPkgWithApprover(String signedXmlFile, String senderGiin, String receiverGiin,  \r\n\t\t\tX509Certificate receiverPublicCert, String approverGiin, \r\n\t\t\tX509Certificate approvercert, int taxyear) throws Exception {\r\n\t\tlogger.debug(\"--> createPkgWithApprover(). signedXmlFile= \" + signedXmlFile + \", senderGiin=\" + senderGiin + \r\n\t\t\t\t\", receiverGiin=\" + receiverGiin + \", approverGiin=\" + approverGiin);\r\n\t\tString idesOutFile = null;\r\n\t\ttry {\r\n\t\t\tDate date = new Date();\r\n\t\t\tString metadatafile = getFileName(senderGiin, \"_Metadata.xml\");\r\n\t\t\tJAXBContext jaxbCtxMetadata = JAXBContext.newInstance(FATCAIDESSenderFileMetadataType.class);            \r\n\t\t\tMarshaller mrshler = jaxbCtxMetadata.createMarshaller();\r\n\t\t\tmrshler.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\r\n\t\t\t\r\n\t\t\tFATCAIDESSenderFileMetadataType metadata = objFMetadata.createFATCAIDESSenderFileMetadataType();\r\n\t\t\tJAXBElement<FATCAIDESSenderFileMetadataType> jaxbElemMetadata = objFMetadata.createFATCAIDESSenderFileMetadata(metadata);\r\n\t\t\t\r\n\t\t\tmetadata.setFATCAEntCommunicationTypeCd(FATCAEntCommunicationTypeCdType.RPT);\r\n\t\t\tmetadata.setFATCAEntitySenderId(senderGiin);\r\n\t\t\tmetadata.setFileRevisionInd(false);\r\n\t\t\tString senderFileId = getIDESFileName(senderGiin);\r\n\t\t\tFile file = new File(senderFileId);\r\n\t\t\tmetadata.setSenderFileId(file.getName());\r\n\t\t\tmetadata.setTaxYear(genTaxYear(taxyear));\r\n\t\t\tmetadata.setFATCAEntityReceiverId(receiverGiin);\r\n\t\t\tmetadata.setFileCreateTs(sdfFileCreateTs.format(date));\r\n\t\t\tmetadata.setSenderContactEmailAddressTxt(metadataEmailAddress);\r\n\t\t\tFileWriter fw = new FileWriter(metadatafile);\r\n\t\t\tmrshler.marshal(jaxbElemMetadata, fw);\r\n\t\t\tfw.close();\r\n\t\t\tString xmlzipFilename;\r\n\t\t\tboolean success = false;\r\n\t\t\txmlzipFilename = getFileName(senderGiin, \"_Payload.zip\");\r\n\t\t\tsuccess = createZipFile(new String[]{signedXmlFile}, xmlzipFilename);\r\n\t\t\tif (success)\r\n\t\t\t\tsuccess = renameZipEntry(xmlzipFilename, getFileName(signedXmlFile), senderGiin + \"_Payload.xml\");\r\n\t\t\tif (!success)\r\n\t\t\t\tthrow new Exception(\"uanble to create \" + xmlzipFilename);\r\n\t\t\tidesOutFile = senderFileId;\r\n\t\t\tCertificate[] certs = null;\r\n\t\t\tString[] encryptedAESKeyOutFiles = null;\r\n\t\t\tif (approvercert != null && approverGiin != null) {\r\n\t\t\t\tcerts = new X509Certificate[] {receiverPublicCert, approvercert};\r\n\t\t\t\tencryptedAESKeyOutFiles = new String[]{getFileName(receiverGiin, \"_Key\"), getFileName(approverGiin, \"_Key\")};\r\n\t\t\t} else if (receiverPublicCert != null){\r\n\t\t\t\tcerts = new X509Certificate[] {receiverPublicCert};\r\n\t\t\t\tencryptedAESKeyOutFiles = new String[]{getFileName(receiverGiin, \"_Key\")};\r\n\t\t\t} else\r\n\t\t\t\tthrow new Exception (\"both approvingEntityCert and receivingEntityCert is null\");\r\n\t\t\tString xmlZippedEncryptedFile = getFileName(senderGiin, \"_Payload\");\r\n\t\t\tsuccess = encrypt(xmlzipFilename, xmlZippedEncryptedFile, certs, encryptedAESKeyOutFiles);\r\n\t\t\tif (! success)\r\n\t\t\t\tthrow new Exception(\"encryption failed. xmlzipFilename=\" + xmlzipFilename);\r\n\t\t\tint count = 0;\r\n\t\t\tString[] infiles = new String[encryptedAESKeyOutFiles.length + 2];\r\n\t\t\tfor (count = 0; count < encryptedAESKeyOutFiles.length; count++)\r\n\t\t\t\tinfiles[count] = encryptedAESKeyOutFiles[count];\r\n\t\t\tinfiles[count++] =  xmlZippedEncryptedFile;\r\n\t\t\tinfiles[count] = metadatafile;\r\n\t\t\tsuccess = createZipFile(infiles, idesOutFile);\r\n\t\t\tif (success) {\r\n\t\t\t\tif (encryptedAESKeyOutFiles.length == 2)\r\n\t\t\t\t\tsuccess = renameZipEntries(idesOutFile, new String[]{getFileName(xmlZippedEncryptedFile), getFileName(metadatafile), \r\n\t\t\t\t\t\t\tgetFileName(encryptedAESKeyOutFiles[0]), getFileName(encryptedAESKeyOutFiles[1])},\r\n\t\t\t\t\t\t\tnew String[]{senderGiin + \"_Payload\", senderGiin + \"_Metadata.xml\", \r\n\t\t\t\t\t\t\treceiverGiin + \"_Key\", approverGiin + \"_Key\"});\r\n\t\t\t\telse\r\n\t\t\t\t\tsuccess = renameZipEntries(idesOutFile, new String[]{getFileName(xmlZippedEncryptedFile), getFileName(metadatafile), \r\n\t\t\t\t\t\tgetFileName(encryptedAESKeyOutFiles[0])},\r\n\t\t\t\t\t\tnew String[]{senderGiin + \"_Payload\", senderGiin + \"_Metadata.xml\", \r\n\t\t\t\t\t\treceiverGiin + \"_Key\"});\r\n\t\t\t}\r\n\t\t\tif (!success)\r\n\t\t\t\tthrow new Exception(\"unable to create zip file \" + idesOutFile);\r\n\t\t\tfor (int i = 0; i < infiles.length; i++)\r\n\t\t\t\tdeleteFile(infiles[i]);\r\n\t\t\tdeleteFile(xmlzipFilename);\r\n\t\t\t//deleteFile(signedXmlFile);\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t\tlogger.debug(\"<-- createPkgWithApprover()\");\r\n\t\treturn idesOutFile;\r\n\t}\r\n\r\n\tprotected boolean decrypt(String cipherTextFile, String encryptedAESKeyFile, String zippedSignedPlainTextFile, PrivateKey privkey) throws Exception {\r\n\t\tlogger.debug(\"--> decrypt(). cipherTextFile= \" + cipherTextFile + \", encryptedAESKeyFile=\" + encryptedAESKeyFile + \r\n\t\t\t\t\", zippedSignedPlainTextFile=\" + zippedSignedPlainTextFile);\r\n\t\tSecretKey skey;\r\n\t\tboolean ret = false;\r\n\t\tBufferedInputStream bis = null;\r\n\t\tbyte[] buf, skeyBuf = null;\r\n\t\tint len, count;\r\n\t\ttry {\r\n\t\t\tbuf = new byte[bufSize];\r\n\t\t\tbis = new BufferedInputStream(new FileInputStream(encryptedAESKeyFile));\r\n\t\t\twhile((len = bis.read(buf)) != -1) {\r\n\t\t\t\tif (skeyBuf == null) {\r\n\t\t\t\t\tskeyBuf = new byte[len];\r\n\t\t\t\t\tSystem.arraycopy(buf, 0, skeyBuf, 0, len);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcount = skeyBuf.length;\r\n\t\t\t\t\tskeyBuf = Arrays.copyOf(skeyBuf, skeyBuf.length + len);\r\n\t\t\t\t\tSystem.arraycopy(buf, 0, skeyBuf, count, len);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbis.close(); bis = null;\r\n\t\t\tCipher cipher = Cipher.getInstance(RSA_TRANSFORMATION);\r\n\t\t\tcipher.init(Cipher.UNWRAP_MODE, privkey);\r\n\t\t\tskey = (SecretKey)cipher.unwrap(skeyBuf, SECRET_KEY_ALGO, Cipher.SECRET_KEY);\r\n\t\t\tret = aes(Cipher.DECRYPT_MODE, cipherTextFile, zippedSignedPlainTextFile, skey);\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(e.getMessage(), e);\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\tif (bis != null) try{bis.close();}catch(Exception e) {}\r\n\t\t}\r\n\t\tlogger.debug(\"<-- createPkgWithApprover()\");\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tprotected void deleteFile(String filename) {\r\n\t\tFile file = new File(filename);\r\n\t\tint attempts = maxAttempts;\r\n\t\twhile (file.exists() && !file.delete() && attempts-->0)\r\n\t\t\tThread.yield();\r\n\t}\r\n\r\n\tpublic boolean unpack(String idesPkgFile, String keystoreType, String keystoreFile, String keystorePwd, String keyPwd, String keyAlias) throws Exception {\r\n\t\tlogger.debug(\"--> unpack(). idesPkgFile=\" + idesPkgFile + \", keystoreType=\" + keystoreType + \r\n\t\t\t\t\", keystoreFile=\" + keystoreFile + \", keyAlias=\" + keyAlias);\r\n\t\tPrivateKey privateKey = UtilShared.getPrivateKey(keystoreType, keystoreFile, keystorePwd, keyPwd, keyAlias);\r\n\t\tboolean flag = unpack (idesPkgFile, privateKey);\r\n\t\tlogger.debug(\"<-- unpack()\");\r\n\t\treturn flag;\r\n\t}\r\n\t\r\n\tpublic boolean unpack(String idesPkgFile, PrivateKey receiverPrivateKey) throws Exception {\r\n\t\tlogger.debug(\"--> unpack(). idesPkgFile=\" + idesPkgFile);\r\n\t\tboolean flag = unpack(idesPkgFile, receiverPrivateKey, false);\r\n\t\tlogger.debug(\"<-- unpack()\");\r\n\t\treturn flag;\r\n\t}\r\n\t\r\n\tpublic boolean unpackForApprover(String idesPkgFile, String approverKeystoreType, String approverKeystoreFile, \r\n\t\t\tString approverKeystorePwd, String approverKeyPwd, String approverKeyAlias) throws Exception {\r\n\t\tlogger.debug(\"--> unpackForApprover(). idesPkgFile=\" + idesPkgFile + \", approverKeystoreType=\" + approverKeystoreType + \r\n\t\t\t\t\", approverKeystoreFile=\" + approverKeystoreFile + \", approverKeyAlias=\" + approverKeyAlias);\r\n\t\tPrivateKey approverPrivateKey = UtilShared.getPrivateKey(approverKeystoreType, approverKeystoreFile, approverKeystorePwd, approverKeyPwd, approverKeyAlias);\r\n\t\tboolean flag = unpackForApprover(idesPkgFile, approverPrivateKey);\r\n\t\tlogger.debug(\"<-- unpackForApprover()\");\r\n\t\treturn flag;\r\n\t}\r\n\t\r\n\tpublic boolean unpackForApprover(String idesPkgFile, PrivateKey approverPrivateKey) throws Exception {\r\n\t\tlogger.debug(\"--> unpackForApprover(). idesPkgFile=\" + idesPkgFile);\r\n\t\tboolean flag = unpack(idesPkgFile, approverPrivateKey, true);\r\n\t\tlogger.debug(\"<-- unpackForApprover()\");\r\n\t\treturn flag;\r\n\t}\r\n\t\r\n\tprotected boolean unpack(String idesPkgFile, PrivateKey privateKey, boolean isApprover) throws Exception {\r\n\t\tlogger.debug(\"--> unpack(). idesPkg=\" + idesPkgFile + \", isApprover=\" + isApprover);\r\n\t\tboolean ret = false;\r\n\t\ttry {\r\n\t\t\tArrayList<String> entryList = unzipFile(idesPkgFile);\r\n\t\t\tString approverKeyFile = null, receiverKeyFile = null, payloadFile = null, metadataFile = null,  receiverGiin = null, filename;\r\n\t\t\t// get metadata file\r\n\t\t\tfor (int i = 0; i < entryList.size(); i++) {\r\n\t\t\t\tfilename = entryList.get(i);\r\n\t\t\t\tif (filename.contains(\"Metadata\"))\r\n\t\t\t\t\tmetadataFile = filename;\r\n\t\t\t\telse if (filename.contains(\"Payload\"))\r\n\t\t\t\t\tpayloadFile = filename;\r\n\t\t\t\telse if (filename.contains(\"Key\")) {\r\n\t\t\t\t\tif (receiverKeyFile == null)\r\n\t\t\t\t\t\treceiverKeyFile = filename;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tapproverKeyFile = filename;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (metadataFile == null)\r\n\t\t\t\tthrow new Exception(\"Invalid package - no metadata file\");\r\n\t\t\tif (payloadFile == null)\r\n\t\t\t\tthrow new Exception(\"Invalid package - no payload file\");\r\n\r\n\t\t\tif (approverKeyFile != null) {\r\n\t\t\t\tJAXBContext jaxbCtxMetadata = JAXBContext.newInstance(\"fatca.idessenderfilemetadata\");\r\n\t\t\t\tUnmarshaller unmrshlr = jaxbCtxMetadata.createUnmarshaller();\r\n\t\t\t\tObject obj = unmrshlr.unmarshal(new File(metadataFile));;\r\n\t\t\t\tif (obj instanceof JAXBElement<?>) {\r\n\t\t\t\t\t@SuppressWarnings(\"unchecked\")\r\n\t\t\t\t\tJAXBElement<FATCAIDESSenderFileMetadataType> jaxbElem = \r\n\t\t\t\t\t\t(JAXBElement<FATCAIDESSenderFileMetadataType>)obj;\r\n\t\t\t\t\tFATCAIDESSenderFileMetadataType metadataObj = jaxbElem.getValue();\r\n\t\t\t\t\treceiverGiin = metadataObj.getFATCAEntityReceiverId();\r\n\t\t\t\t\tif (!receiverKeyFile.contains(receiverGiin)) {\r\n\t\t\t\t\t\tfilename = approverKeyFile;\r\n\t\t\t\t\t\tapproverKeyFile = receiverKeyFile;\r\n\t\t\t\t\t\treceiverKeyFile = filename;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (receiverKeyFile != null)\r\n\t\t\t\treceiverGiin = receiverKeyFile.substring(0, receiverKeyFile.length() - \"_Key\".length());\r\n\t\t\tif (receiverGiin == null)\r\n\t\t\t\tthrow new Exception(\"Invalid metadata file - missing receiver giin or corrupt zip file - no reveiverKeyFile\");\r\n\t\t\tif (isApprover && approverKeyFile == null)\r\n\t\t\t\tthrow new Exception(\"Invalid package - no approverKeyFile\");\r\n\t\t\tString zippedSignedPlainTextFile = getFileName(receiverGiin, \"_Payload.zip\");\r\n\t\t\tif (approverKeyFile != null && isApprover)\r\n\t\t\t\tret = decrypt(payloadFile, approverKeyFile, zippedSignedPlainTextFile, privateKey);\r\n\t\t\telse\r\n\t\t\t\tret = decrypt(payloadFile, receiverKeyFile, zippedSignedPlainTextFile, privateKey);\r\n\r\n\t\t\tif (ret) {\r\n\t\t\t\tif (unzipFile(zippedSignedPlainTextFile) == null)\r\n\t\t\t\t\tret = false;\r\n\t\t\t\telse\r\n\t\t\t\t\tdeleteFile(zippedSignedPlainTextFile);\r\n\t\t\t}\r\n\t\t\tdeleteFile(payloadFile);\r\n\t\t\t//deleteFile(metadataFile);\r\n\t\t\tdeleteFile(receiverKeyFile);\r\n\t\t\tif (approverKeyFile != null)\r\n\t\t\t\tdeleteFile(approverKeyFile);\r\n\t\t} catch(Exception e) {\r\n\t\t\tlogger.error(e.getMessage());\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t\tlogger.debug(\"<-- unpack()\");\r\n\t\treturn ret;\r\n\t}\r\n}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}